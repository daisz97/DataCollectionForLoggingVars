public	O	O
void	O	O
simpleReadAfterWrite	O	O
(	O	O
final	O	O
FileSystem	O	O
fs	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

private	O	O
File	O	TRUE
createDir	O	O
(	O	O
String	O	O
dirPath	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
File	O	TRUE
dir	O	TRUE
=	O	O
new	O	O
File	O	TRUE
(	O	O
dirPath	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
dir	O	TRUE
.	O	O
exists	O	O
(	O	O
)	O	O
)	O	O
{	O	O

try	O	O
{	O	O
InputStream	O	TRUE
inputStream	O	TRUE
=	O	O
this	O	O
.	O	O
store	O	TRUE
.	O	O
retrieveBlock	O	TRUE
(	O	O
this	O	O
.	O	O
key	O	TRUE
,	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getStart	O	TRUE
(	O	O
)	O	O
,	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getEnd	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
IOUtils	O	TRUE
.	O	O
readFully	O	TRUE
(	O	O
inputStream	O	TRUE
,	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getBuffer	O	TRUE
(	O	O
)	O	O
,	O	O
0	O	O
,	O	O
readBuffer	O	TRUE
.	O	O
getBuffer	O	TRUE
(	O	O
)	O	O
.	O	O
length	O	TRUE
)	O	O
;	O	O
inputStream	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
setStatus	O	TRUE
(	O	O
CosNInputStream	O	TRUE
.	O	O
ReadBuffer	O	TRUE
.	O	O
SUCCESS	O	TRUE
)	O	O
;	O	O
break	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	O	TRUE
)	O	O
{	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
setStatus	O	TRUE
(	O	O
CosNInputStream	O	TRUE
.	O	O
ReadBuffer	O	TRUE
.	O	O
ERROR	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
String	O	TRUE
.	O	O
valueOf	O	TRUE
(	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getStart	O	TRUE
(	O	O
)	O	O
)	O	O
+	O	O
+	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getEnd	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
try	O	O
{	O	O
retryAction	O	TRUE
=	O	O
this	O	O
.	O	O
retryPolicy	O	TRUE
.	O	O
shouldRetry	O	TRUE
(	O	O
e	O	TRUE
,	O	O
retries	O	TRUE
++	O	O
,	O	O
0	O	O
,	O	O
true	O	O
)	O	O
;	O	O
if	O	O
(	O	O
retryAction	O	TRUE
.	O	O
action	O	O
==	O	O
RetryPolicy	O	O
.	O	O
RetryAction	O	O
.	O	O
RetryDecision	O	O
.	O	O
RETRY	O	O
)	O	O
{	O	O
Thread	O	TRUE
.	O	O
sleep	O	TRUE
(	O	O
retryAction	O	TRUE
.	O	O
delayMillis	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e1	TRUE	TRUE
)	O	O
{	O	O
String	O	TRUE
errMsg	TRUE	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
,	O	O
this	O	O
.	O	O
retryPolicy	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
,	O	O
String	O	TRUE
.	O	O
valueOf	O	TRUE
(	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getStart	O	TRUE
(	O	O
)	O	O
)	O	O
,	O	O
String	O	TRUE
.	O	O
valueOf	O	TRUE
(	O	O
this	O	O
.	O	O
readBuffer	O	TRUE
.	O	O
getEnd	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O

try	O	O
{	O	O
String	O	TRUE
userName	O	TRUE
=	O	O
System	O	TRUE
.	O	O
getProperty	O	TRUE
(	O	O
)	O	O
;	O	O
String	O	TRUE
command	O	TRUE
=	O	O
+	O	O
userName	O	TRUE
;	O	O
if	O	O
(	O	O
!	O	O
getOwnerId	O	O
)	O	O
{	O	O
command	O	TRUE
=	O	O
+	O	O
userName	O	TRUE
;	O	O
}	O	O
Process	O	TRUE
child	O	TRUE
=	O	O
Runtime	O	TRUE
.	O	O
getRuntime	O	TRUE
(	O	O
)	O	O
.	O	O
exec	O	TRUE
(	O	O
command	O	TRUE
)	O	O
;	O	O
child	O	TRUE
.	O	O
waitFor	O	TRUE
(	O	O
)	O	O
;	O	O
InputStream	O	TRUE
in	O	TRUE
=	O	O
child	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
;	O	O
StringBuilder	O	TRUE
strBuffer	O	TRUE
=	O	O
new	O	O
StringBuilder	O	TRUE
(	O	O
)	O	O
;	O	O
int	O	O
c	O	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
c	O	TRUE
=	O	O
in	O	TRUE
.	O	O
read	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
-	O	O
1	O	O
)	O	O
{	O	O
strBuffer	O	TRUE
.	O	O
append	O	TRUE
(	O	O
(	O	O
char	O	O
)	O	O
c	O	TRUE
)	O	O
;	O	O
}	O	O
in	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
ownerInfoId	O	TRUE
=	O	O
strBuffer	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
|	O	O
InterruptedException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
boolean	O	O
delete	O	O
(	O	O
Path	O	O
f	TRUE	TRUE
,	O	O
boolean	O	O
recursive	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

if	O	O
(	O	O
!	O	O
key	TRUE	TRUE
.	O	O
endsWith	O	O
(	O	O
PATH_DELIMITER	O	TRUE
)	O	O
)	O	O
{	O	O
key	TRUE	TRUE
+=	O	O
PATH_DELIMITER	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
!	O	O
recursive	O	O
&&	O	O
listStatus	O	O
(	O	O
f	O	TRUE
)	O	O
.	O	O
length	O	O
>	O	O
0	O	O
)	O	O
{	O	O
String	O	TRUE
errMsg	O	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
,	O	O
f	O	TRUE
)	O	O
;	O	O
throw	O	O
new	O	O
IOException	O	TRUE
(	O	O
errMsg	O	TRUE
)	O	O
;	O	O
}	O	O
createParent	O	TRUE
(	O	O
f	O	TRUE
)	O	O
;	O	O
String	O	TRUE
priorLastKey	O	TRUE
=	O	O
null	O	O
;	O	O
do	O	O
{	O	O
PartialListing	O	TRUE
listing	O	TRUE
=	O	O
store	O	TRUE
.	O	O
list	O	TRUE
(	O	O
key	TRUE	TRUE
,	O	O
Constants	O	TRUE
.	O	O
COS_MAX_LISTING_LENGTH	O	TRUE
,	O	O
priorLastKey	O	TRUE
,	O	O
true	O	O
)	O	O
;	O	O
for	O	O
(	O	O
FileMetadata	O	O
file	O	TRUE
:	O	O
listing	O	TRUE
.	O	O
getFiles	O	O
(	O	O
)	O	O
)	O	O
{	O	O
store	O	TRUE
.	O	O
delete	O	TRUE
(	O	O
file	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
for	O	O
(	O	O
FileMetadata	O	O
commonPrefix	O	TRUE
:	O	O
listing	O	TRUE
.	O	O
getCommonPrefixes	O	O
(	O	O
)	O	O
)	O	O
{	O	O
store	O	TRUE
.	O	O
delete	O	TRUE
(	O	O
commonPrefix	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
priorLastKey	O	TRUE
=	O	O
listing	O	TRUE
.	O	O
getPriorLastKey	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
while	O	O
(	O	O
priorLastKey	O	TRUE
!=	O	O
null	O	O
)	O	O
;	O	O

}	O	O
if	O	O
(	O	O
!	O	O
recursive	O	O
&&	O	O
listStatus	O	O
(	O	O
f	TRUE	TRUE
)	O	O
.	O	O
length	O	O
>	O	O
0	O	O
)	O	O
{	O	O
String	O	TRUE
errMsg	O	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
,	O	O
f	TRUE	TRUE
)	O	O
;	O	O
throw	O	O
new	O	O
IOException	O	TRUE
(	O	O
errMsg	O	TRUE
)	O	O
;	O	O
}	O	O
createParent	O	TRUE
(	O	O
f	TRUE	TRUE
)	O	O
;	O	O
String	O	TRUE
priorLastKey	O	TRUE
=	O	O
null	O	O
;	O	O
do	O	O
{	O	O
PartialListing	O	TRUE
listing	O	TRUE
=	O	O
store	O	TRUE
.	O	O
list	O	TRUE
(	O	O
key	O	TRUE
,	O	O
Constants	O	TRUE
.	O	O
COS_MAX_LISTING_LENGTH	O	TRUE
,	O	O
priorLastKey	O	TRUE
,	O	O
true	O	O
)	O	O
;	O	O
for	O	O
(	O	O
FileMetadata	O	O
file	O	TRUE
:	O	O
listing	O	TRUE
.	O	O
getFiles	O	O
(	O	O
)	O	O
)	O	O
{	O	O
store	O	TRUE
.	O	O
delete	O	TRUE
(	O	O
file	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
for	O	O
(	O	O
FileMetadata	O	O
commonPrefix	O	TRUE
:	O	O
listing	O	TRUE
.	O	O
getCommonPrefixes	O	O
(	O	O
)	O	O
)	O	O
{	O	O
store	O	TRUE
.	O	O
delete	O	TRUE
(	O	O
commonPrefix	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
priorLastKey	O	TRUE
=	O	O
listing	O	TRUE
.	O	O
getPriorLastKey	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
while	O	O
(	O	O
priorLastKey	O	TRUE
!=	O	O
null	O	O
)	O	O
;	O	O
try	O	O
{	O	O
store	O	TRUE
.	O	O
delete	O	TRUE
(	O	O
key	O	TRUE
)	O	O
;	O	O

}	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
f	TRUE	TRUE
)	O	O
;	O	O
FileMetadata	O	TRUE
meta	O	TRUE
=	O	O
store	O	TRUE
.	O	O
retrieveMetadata	O	TRUE
(	O	O
key	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
meta	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
meta	O	TRUE
.	O	O
isFile	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
f	TRUE	TRUE
,	O	O
key	TRUE	TRUE
)	O	O
;	O	O
return	O	O
newFile	O	TRUE
(	O	O
meta	O	TRUE
,	O	O
absolutePath	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
f	TRUE	TRUE
,	O	O
key	TRUE	TRUE
)	O	O
;	O	O
return	O	O
newDirectory	O	TRUE
(	O	O
meta	O	TRUE
,	O	O
absolutePath	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
if	O	O
(	O	O
!	O	O
key	TRUE	TRUE
.	O	O
endsWith	O	O
(	O	O
PATH_DELIMITER	O	TRUE
)	O	O
)	O	O
{	O	O
key	TRUE	TRUE
+=	O	O
PATH_DELIMITER	O	TRUE
;	O	O
}	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
key	TRUE	TRUE
)	O	O
;	O	O
PartialListing	O	TRUE
listing	O	TRUE
=	O	O
store	O	TRUE
.	O	O
list	O	TRUE
(	O	O
key	TRUE	TRUE
,	O	O
1	O	O
)	O	O
;	O	O
if	O	O
(	O	O
listing	O	TRUE
.	O	O
getFiles	O	O
(	O	O
)	O	O
.	O	O
length	O	O
>	O	O
0	O	O
||	O	O
listing	O	TRUE
.	O	O
getCommonPrefixes	O	O
(	O	O
)	O	O
.	O	O
length	O	O
>	O	O
0	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

String	O	TRUE
key	TRUE	TRUE
=	O	O
pathToKey	O	TRUE
(	O	O
absolutePath	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
key	TRUE	TRUE
.	O	O
length	O	O
(	O	O
)	O	O
>	O	O
0	O	O
)	O	O
{	O	O
FileStatus	O	TRUE
fileStatus	O	TRUE
=	O	O
this	O	O
.	O	O
getFileStatus	O	TRUE
(	O	O
f	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
fileStatus	O	TRUE
.	O	O
isFile	O	O
(	O	O
)	O	O
)	O	O
{	O	O
return	O	O
new	O	O
FileStatus	O	TRUE
[	O	O
]	O	O
{	O	O
fileStatus	O	TRUE
}	O	O
;	O	O
}	O	O
}	O	O
if	O	O
(	O	O
!	O	O
key	TRUE	TRUE
.	O	O
endsWith	O	O
(	O	O
PATH_DELIMITER	O	TRUE
)	O	O
)	O	O
{	O	O
key	TRUE	TRUE
+=	O	O
PATH_DELIMITER	O	TRUE
;	O	O
}	O	O
URI	O	TRUE
pathUri	O	TRUE
=	O	O
absolutePath	O	TRUE
.	O	O
toUri	O	TRUE
(	O	O
)	O	O
;	O	O
Set	O	TRUE
<	O	O
FileStatus	O	TRUE
>	O	O
status	O	TRUE
=	O	O
new	O	O
TreeSet	O	TRUE
<	O	O
>	O	O
(	O	O
)	O	O
;	O	O
String	O	TRUE
priorLastKey	O	TRUE
=	O	O
null	O	O
;	O	O
do	O	O
{	O	O
PartialListing	O	TRUE
listing	O	TRUE
=	O	O
store	O	TRUE
.	O	O
list	O	TRUE
(	O	O
key	TRUE	TRUE
,	O	O
Constants	O	TRUE
.	O	O
COS_MAX_LISTING_LENGTH	O	TRUE
,	O	O
priorLastKey	O	TRUE
,	O	O
false	O	O
)	O	O
;	O	O
for	O	O
(	O	O
FileMetadata	O	O
fileMetadata	O	TRUE
:	O	O
listing	O	TRUE
.	O	O
getFiles	O	O
(	O	O
)	O	O
)	O	O
{	O	O
Path	O	TRUE
subPath	O	TRUE
=	O	O
keyToPath	O	TRUE
(	O	O
fileMetadata	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
fileMetadata	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
.	O	O
equals	O	O
(	O	O
key	TRUE	TRUE
)	O	O
)	O	O
{	O	O

List	O	TRUE
<	O	O
Path	O	TRUE
>	O	O
paths	O	TRUE
=	O	O
new	O	O
ArrayList	O	TRUE
<	O	O
>	O	O
(	O	O
)	O	O
;	O	O
do	O	O
{	O	O
paths	O	TRUE
.	O	O
add	O	TRUE
(	O	O
absolutePath	O	TRUE
)	O	O
;	O	O
absolutePath	O	TRUE
=	O	O
absolutePath	O	TRUE
.	O	O
getParent	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
while	O	O
(	O	O
absolutePath	O	TRUE
!=	O	O
null	O	O
)	O	O
;	O	O
for	O	O
(	O	O
Path	O	TRUE
path	O	TRUE
:	O	O
paths	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
path	O	TRUE
.	O	O
equals	O	O
(	O	O
new	O	O
Path	O	TRUE
(	O	O
CosNFileSystem	O	O
.	O	O
PATH_DELIMITER	O	O
)	O	O
)	O	O
)	O	O
{	O	O
break	O	O
;	O	O
}	O	O
try	O	O
{	O	O
FileStatus	O	TRUE
fileStatus	O	TRUE
=	O	O
getFileStatus	O	TRUE
(	O	O
path	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
fileStatus	O	TRUE
.	O	O
isFile	O	O
(	O	O
)	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
FileAlreadyExistsException	O	TRUE
(	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
,	O	O
f	TRUE	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
fileStatus	O	TRUE
.	O	O
isDirectory	O	O
(	O	O
)	O	O
)	O	O
{	O	O
break	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
FileNotFoundException	O	O
e	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
boolean	O	O
rename	O	O
(	O	O
Path	O	O
src	TRUE	TRUE
,	O	O
Path	O	O
dst	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
dstParentPath	O	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
null	O	O
!=	O	O
dstParentPath	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
src	TRUE	TRUE
,	O	O
dst	TRUE	TRUE
)	O	O
;	O	O
throw	O	O
new	O	O
IOException	O	TRUE
(	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
,	O	O
src	TRUE	TRUE
,	O	O
dst	TRUE	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
FileStatus	O	TRUE
dstFileStatus	O	TRUE
;	O	O
try	O	O
{	O	O
dstFileStatus	O	TRUE
=	O	O
this	O	O
.	O	O
getFileStatus	O	TRUE
(	O	O
dst	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
dstFileStatus	O	TRUE
.	O	O
isFile	O	O
(	O	O
)	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
FileAlreadyExistsException	O	TRUE
(	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
,	O	O
dstFileStatus	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
dst	TRUE	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
dst	TRUE	TRUE
,	O	O
src	TRUE	TRUE
.	O	O
getName	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
FileStatus	O	TRUE
[	O	O
]	O	O
statuses	O	TRUE
;	O	O
try	O	O
{	O	O
statuses	O	TRUE
=	O	O
this	O	O
.	O	O
listStatus	O	TRUE
(	O	O
dst	TRUE	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
FileNotFoundException	O	O
e	O	O
)	O	O
{	O	O

private	O	O
void	O	O
createParent	O	O
(	O	O
Path	O	TRUE
path	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
Path	O	TRUE
parent	O	TRUE
=	O	O
path	O	TRUE
.	O	O
getParent	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
parent	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
String	O	TRUE
parentKey	TRUE	TRUE
=	O	O
pathToKey	O	TRUE
(	O	O
parent	O	TRUE
)	O	O
;	O	O

else	O	O
{	O	O
PartETag	O	TRUE
partETag	O	TRUE
=	O	O
null	O	O
;	O	O
if	O	O
(	O	O
this	O	O
.	O	O
blockWritten	O	TRUE
>	O	O
0	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
,	O	O
this	O	O
.	O	O
currentBlockId	O	TRUE
,	O	O
this	O	O
.	O	O
blockWritten	O	TRUE
)	O	O
;	O	O
partETag	O	TRUE
=	O	O
store	O	TRUE
.	O	O
uploadPart	O	TRUE
(	O	O
new	O	O
ByteBufferInputStream	O	TRUE
(	O	O
currentBlockBuffer	O	TRUE
.	O	O
getByteBuffer	O	TRUE
(	O	O
)	O	O
)	O	O
,	O	O
key	TRUE	TRUE
,	O	O
uploadId	O	TRUE
,	O	O
currentBlockId	O	TRUE
+	O	O
1	O	O
,	O	O
currentBlockBuffer	O	TRUE
.	O	O
getByteBuffer	O	TRUE
(	O	O
)	O	O
.	O	O
remaining	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
final	O	O
List	O	TRUE
<	O	O
PartETag	O	TRUE
>	O	O
futurePartETagList	O	TRUE
=	O	O
this	O	O
.	O	O
waitForFinishPartUploads	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
null	O	O
==	O	O
futurePartETagList	O	TRUE
)	O	O
{	O	O
throw	O	O
new	O	O
IOException	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
List	O	TRUE
<	O	O
PartETag	O	TRUE
>	O	O
tmpPartEtagList	O	TRUE
=	O	O
new	O	O
LinkedList	O	TRUE
<	O	O
>	O	O
(	O	O
futurePartETagList	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
null	O	O
!=	O	O
partETag	O	TRUE
)	O	O
{	O	O
tmpPartEtagList	O	TRUE
.	O	O
add	O	TRUE
(	O	O
partETag	O	TRUE
)	O	O
;	O	O
}	O	O
store	O	TRUE
.	O	O
completeMultipartUpload	O	TRUE
(	O	O
this	O	O
.	O	O
key	TRUE	TRUE
,	O	O
this	O	O
.	O	O
uploadId	O	TRUE
,	O	O
tmpPartEtagList	O	TRUE
)	O	O
;	O	O
}	O	O
try	O	O
{	O	O
BufferPool	O	TRUE
.	O	O
getInstance	O	TRUE
(	O	O
)	O	O
.	O	O
returnBuffer	O	TRUE
(	O	O
this	O	O
.	O	O
currentBlockBuffer	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
InterruptedException	O	O
e	O	O
)	O	O
{	O	O

private	O	O
void	O	O
storeFileWithRetry	O	O
(	O	O
String	O	O
key	TRUE	TRUE
,	O	O
InputStream	O	O
inputStream	O	TRUE
,	O	O
byte	O	O
[	O	O
]	O	O
md5Hash	O	TRUE
,	O	O
long	O	O
length	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
try	O	O
{	O	O
ObjectMetadata	O	TRUE
objectMetadata	O	TRUE
=	O	O
new	O	O
ObjectMetadata	O	TRUE
(	O	O
)	O	O
;	O	O
objectMetadata	O	TRUE
.	O	O
setContentMD5	O	TRUE
(	O	O
Base64	O	TRUE
.	O	O
encodeAsString	O	TRUE
(	O	O
md5Hash	O	TRUE
)	O	O
)	O	O
;	O	O
objectMetadata	O	TRUE
.	O	O
setContentLength	O	TRUE
(	O	O
length	O	TRUE
)	O	O
;	O	O
PutObjectRequest	O	TRUE
putObjectRequest	O	TRUE
=	O	O
new	O	O
PutObjectRequest	O	TRUE
(	O	O
bucketName	O	TRUE
,	O	O
key	TRUE	TRUE
,	O	O
inputStream	O	TRUE
,	O	O
objectMetadata	O	TRUE
)	O	O
;	O	O
PutObjectResult	O	TRUE
putObjectResult	TRUE	TRUE
=	O	O
(	O	O
PutObjectResult	O	TRUE
)	O	O
callCOSClientWithRetry	O	TRUE
(	O	O
putObjectRequest	O	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
storeFile	O	O
(	O	O
String	O	O
key	TRUE	TRUE
,	O	O
File	O	O
file	TRUE	TRUE
,	O	O
byte	O	O
[	O	O
]	O	O
md5Hash	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
storeFile	O	O
(	O	O
String	O	O
key	TRUE	TRUE
,	O	O
InputStream	O	O
inputStream	O	O
,	O	O
byte	O	O
[	O	O
]	O	O
md5Hash	O	O
,	O	O
long	O	O
contentLength	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

public	O	O
void	O	O
abortMultipartUpload	O	O
(	O	O
String	O	O
key	TRUE	TRUE
,	O	O
String	O	O
uploadId	TRUE	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
InputStream	O	O
retrieve	O	O
(	O	O
String	O	O
key	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
InputStream	O	O
retrieve	O	O
(	O	O
String	O	O
key	TRUE	TRUE
,	O	O
long	O	O
byteRangeStart	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
try	O	O
{	O	O

private	O	O
PartialListing	O	O
list	O	O
(	O	O
String	O	O
prefix	TRUE	TRUE
,	O	O
String	O	O
delimiter	TRUE	TRUE
,	O	O
int	O	O
maxListingLength	TRUE	TRUE
,	O	O
String	O	O
priorLastKey	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

private	O	O
PartialListing	O	O
list	O	O
(	O	O
String	O	TRUE
prefix	O	TRUE
,	O	O
String	O	TRUE
delimiter	O	TRUE
,	O	O
int	O	O
maxListingLength	O	TRUE
,	O	O
String	O	TRUE
priorLastKey	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
prefix	O	TRUE
,	O	O
delimiter	O	TRUE
,	O	O
maxListingLength	O	TRUE
,	O	O
priorLastKey	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
prefix	O	TRUE
.	O	O
startsWith	O	O
(	O	O
CosNFileSystem	O	TRUE
.	O	O
PATH_DELIMITER	O	TRUE
)	O	O
)	O	O
{	O	O
prefix	O	TRUE
+=	O	O
CosNFileSystem	O	TRUE
.	O	O
PATH_DELIMITER	O	TRUE
;	O	O
}	O	O
ListObjectsRequest	O	TRUE
listObjectsRequest	O	TRUE
=	O	O
new	O	O
ListObjectsRequest	O	TRUE
(	O	O
)	O	O
;	O	O
listObjectsRequest	O	TRUE
.	O	O
setBucketName	O	TRUE
(	O	O
bucketName	O	TRUE
)	O	O
;	O	O
listObjectsRequest	O	TRUE
.	O	O
setPrefix	O	TRUE
(	O	O
prefix	O	TRUE
)	O	O
;	O	O
listObjectsRequest	O	TRUE
.	O	O
setDelimiter	O	TRUE
(	O	O
delimiter	O	TRUE
)	O	O
;	O	O
listObjectsRequest	O	TRUE
.	O	O
setMarker	O	TRUE
(	O	O
priorLastKey	O	TRUE
)	O	O
;	O	O
listObjectsRequest	O	TRUE
.	O	O
setMaxKeys	O	TRUE
(	O	O
maxListingLength	O	TRUE
)	O	O
;	O	O
ObjectListing	O	TRUE
objectListing	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
objectListing	O	TRUE
=	O	O
(	O	O
ObjectListing	O	TRUE
)	O	O
callCOSClientWithRetry	O	TRUE
(	O	O
listObjectsRequest	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	O	TRUE
)	O	O
{	O	O
String	O	TRUE
errMsg	TRUE	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
+	O	O
,	O	O
prefix	O	TRUE
,	O	O
(	O	O
delimiter	O	TRUE
==	O	O
null	O	O
)	O	O
?	O	O
:	O	O
delimiter	O	TRUE
,	O	O
maxListingLength	O	TRUE
,	O	O
priorLastKey	O	TRUE
,	O	O
e	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
delete	O	O
(	O	O
String	O	O
key	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

public	O	O
void	O	O
rename	O	O
(	O	O
String	O	O
srcKey	TRUE	TRUE
,	O	O
String	O	O
dstKey	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
copy	O	O
(	O	O
String	O	O
srcKey	TRUE	TRUE
,	O	O
String	O	O
dstKey	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
long	O	O
getFileLength	O	O
(	O	O
String	O	O
key	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

else	O	O
if	O	O
(	O	O
request	O	TRUE
instanceof	O	O
ListObjectsRequest	O	TRUE
)	O	O
{	O	O
sdkMethod	O	TRUE
=	O	O
;	O	O
return	O	O
this	O	O
.	O	O
cosClient	O	TRUE
.	O	O
listObjects	O	TRUE
(	O	O
(	O	O
ListObjectsRequest	O	TRUE
)	O	O
request	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
throw	O	O
new	O	O
IOException	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
CosServiceException	O	O
cse	O	TRUE
)	O	O
{	O	O
String	O	TRUE
errMsg	TRUE	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
+	O	O
,	O	O
retryIndex	O	TRUE
,	O	O
this	O	O
.	O	O
maxRetryTimes	O	TRUE
,	O	O
sdkMethod	O	TRUE
,	O	O
cse	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
int	O	O
statusCode	O	TRUE
=	O	O
cse	O	TRUE
.	O	O
getStatusCode	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
statusCode	O	TRUE
/	O	O
100	O	O
==	O	O
5	O	O
)	O	O
{	O	O
if	O	O
(	O	O
retryIndex	O	TRUE
<=	O	O
this	O	O
.	O	O
maxRetryTimes	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
errMsg	TRUE	TRUE
)	O	O
;	O	O
long	O	O
sleepLeast	O	TRUE
=	O	O
retryIndex	O	TRUE
*	O	O
300L	O	O
;	O	O
long	O	O
sleepBound	O	TRUE
=	O	O
retryIndex	O	TRUE
*	O	O
500L	O	O
;	O	O
try	O	O
{	O	O
if	O	O
(	O	O
request	O	TRUE
instanceof	O	O
UploadPartRequest	O	O
)	O	O
{	O	O

}	O	O
}	O	O
catch	O	O
(	O	O
CosServiceException	O	O
cse	O	TRUE
)	O	O
{	O	O
String	O	TRUE
errMsg	TRUE	TRUE
=	O	O
String	O	TRUE
.	O	O
format	O	TRUE
(	O	O
+	O	O
+	O	O
,	O	O
retryIndex	O	TRUE
,	O	O
this	O	O
.	O	O
maxRetryTimes	O	TRUE
,	O	O
sdkMethod	O	TRUE
,	O	O
cse	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
int	O	O
statusCode	O	TRUE
=	O	O
cse	O	TRUE
.	O	O
getStatusCode	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
statusCode	O	TRUE
/	O	O
100	O	O
==	O	O
5	O	O
)	O	O
{	O	O
if	O	O
(	O	O
retryIndex	O	TRUE
<=	O	O
this	O	O
.	O	O
maxRetryTimes	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
errMsg	TRUE	TRUE
)	O	O
;	O	O
long	O	O
sleepLeast	O	TRUE
=	O	O
retryIndex	O	TRUE
*	O	O
300L	O	O
;	O	O
long	O	O
sleepBound	O	TRUE
=	O	O
retryIndex	O	TRUE
*	O	O
500L	O	O
;	O	O
try	O	O
{	O	O
if	O	O
(	O	O
request	O	TRUE
instanceof	O	O
UploadPartRequest	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
(	O	O
(	O	O
UploadPartRequest	O	TRUE
)	O	O
request	O	TRUE
)	O	O
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
instanceof	O	O
ByteBufferInputStream	O	O
)	O	O
{	O	O
(	O	O
(	O	O
UploadPartRequest	O	TRUE
)	O	O
request	O	TRUE
)	O	O
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
.	O	O
reset	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
Thread	O	TRUE
.	O	O
sleep	O	TRUE
(	O	O
ThreadLocalRandom	O	TRUE
.	O	O
current	O	TRUE
(	O	O
)	O	O
.	O	O
nextLong	O	TRUE
(	O	O
sleepLeast	O	TRUE
,	O	O
sleepBound	O	TRUE
)	O	O
)	O	O
;	O	O
++	O	O
retryIndex	O	TRUE
;	O	O
}	O	O
catch	O	O
(	O	O
InterruptedException	O	O
e	O	O
)	O	O
{	O	O

@	O	O
Test	O	O
public	O	O
void	O	O
testSeek	O	O
(	O	O
)	O	O
throws	O	O
Exception	O	O
{	O	O
Path	O	TRUE
seekTestFilePath	O	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
this	O	O
.	O	O
testRootDir	O	TRUE
+	O	O
+	O	O
)	O	O
;	O	O
long	O	O
fileSize	O	TRUE
=	O	O
5	O	O
*	O	O
Unit	O	TRUE
.	O	O
MB	O	TRUE
;	O	O
ContractTestUtils	O	TRUE
.	O	O
generateTestFile	O	TRUE
(	O	O
this	O	O
.	O	O
fs	O	TRUE
,	O	O
seekTestFilePath	O	TRUE
,	O	O
fileSize	O	TRUE
,	O	O
256	O	O
,	O	O
255	O	O
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
FSDataInputStream	O	TRUE
inputStream	TRUE	TRUE
=	O	O
this	O	O
.	O	O
fs	O	TRUE
.	O	O
open	O	TRUE
(	O	O
seekTestFilePath	O	TRUE
)	O	O
;	O	O
int	O	O
seekTimes	O	TRUE
=	O	O
5	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
!=	O	O
seekTimes	O	TRUE
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
long	O	O
pos	O	TRUE
=	O	O
fileSize	O	TRUE
/	O	O
(	O	O
seekTimes	O	TRUE
-	O	O
i	O	TRUE
)	O	O
-	O	O
1	O	O
;	O	O
inputStream	TRUE	TRUE
.	O	O
seek	O	TRUE
(	O	O
pos	O	TRUE
)	O	O
;	O	O
assertTrue	O	TRUE
(	O	O
+	O	O
pos	O	TRUE
+	O	O
+	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
,	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
==	O	O
pos	O	TRUE
)	O	O
;	O	O

Path	O	TRUE
seekTestFilePath	O	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
this	O	O
.	O	O
testRootDir	O	TRUE
+	O	O
+	O	O
)	O	O
;	O	O
long	O	O
fileSize	O	TRUE
=	O	O
5	O	O
*	O	O
Unit	O	TRUE
.	O	O
MB	O	TRUE
;	O	O
ContractTestUtils	O	TRUE
.	O	O
generateTestFile	O	TRUE
(	O	O
this	O	O
.	O	O
fs	O	TRUE
,	O	O
seekTestFilePath	O	TRUE
,	O	O
fileSize	O	TRUE
,	O	O
256	O	O
,	O	O
255	O	O
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
FSDataInputStream	O	TRUE
inputStream	O	TRUE
=	O	O
this	O	O
.	O	O
fs	O	TRUE
.	O	O
open	O	TRUE
(	O	O
seekTestFilePath	O	TRUE
)	O	O
;	O	O
int	O	O
seekTimes	O	TRUE
=	O	O
5	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
!=	O	O
seekTimes	O	TRUE
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
long	O	O
pos	TRUE	TRUE
=	O	O
fileSize	O	TRUE
/	O	O
(	O	O
seekTimes	O	TRUE
-	O	O
i	O	TRUE
)	O	O
-	O	O
1	O	O
;	O	O
inputStream	O	TRUE
.	O	O
seek	O	TRUE
(	O	O
pos	TRUE	TRUE
)	O	O
;	O	O
assertTrue	O	TRUE
(	O	O
+	O	O
pos	TRUE	TRUE
+	O	O
+	O	O
inputStream	O	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
,	O	O
inputStream	O	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
==	O	O
pos	TRUE	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
inputStream	O	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
Random	O	TRUE
random	O	TRUE
=	O	O
new	O	O
Random	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
<	O	O
seekTimes	O	TRUE
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
long	O	O
pos	TRUE	TRUE
=	O	O
Math	O	TRUE
.	O	O
abs	O	TRUE
(	O	O
random	O	TRUE
.	O	O
nextLong	O	TRUE
(	O	O
)	O	O
)	O	O
%	O	O
fileSize	O	TRUE
;	O	O

LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
FSDataInputStream	O	TRUE
inputStream	TRUE	TRUE
=	O	O
this	O	O
.	O	O
fs	O	TRUE
.	O	O
open	O	TRUE
(	O	O
seekTestFilePath	O	TRUE
)	O	O
;	O	O
int	O	O
seekTimes	O	TRUE
=	O	O
5	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
!=	O	O
seekTimes	O	TRUE
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
long	O	O
pos	O	TRUE
=	O	O
fileSize	O	TRUE
/	O	O
(	O	O
seekTimes	O	TRUE
-	O	O
i	O	TRUE
)	O	O
-	O	O
1	O	O
;	O	O
inputStream	TRUE	TRUE
.	O	O
seek	O	TRUE
(	O	O
pos	O	TRUE
)	O	O
;	O	O
assertTrue	O	TRUE
(	O	O
+	O	O
pos	O	TRUE
+	O	O
+	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
,	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
==	O	O
pos	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
Random	O	TRUE
random	O	TRUE
=	O	O
new	O	O
Random	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
<	O	O
seekTimes	O	TRUE
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
long	O	O
pos	O	TRUE
=	O	O
Math	O	TRUE
.	O	O
abs	O	TRUE
(	O	O
random	O	TRUE
.	O	O
nextLong	O	TRUE
(	O	O
)	O	O
)	O	O
%	O	O
fileSize	O	TRUE
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
pos	O	TRUE
)	O	O
;	O	O
inputStream	TRUE	TRUE
.	O	O
seek	O	TRUE
(	O	O
pos	O	TRUE
)	O	O
;	O	O
assertTrue	O	TRUE
(	O	O
+	O	O
pos	O	TRUE
+	O	O
+	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
,	O	O
inputStream	TRUE	TRUE
.	O	O
getPos	O	TRUE
(	O	O
)	O	O
==	O	O
pos	O	TRUE
)	O	O
;	O	O

@	O	O
Test	O	O
public	O	O
void	O	O
testRead	O	O
(	O	O
)	O	O
throws	O	O
Exception	O	O
{	O	O
final	O	O
int	O	O
bufLen	O	TRUE
=	O	O
256	O	O
;	O	O
Path	O	TRUE
readTestFilePath	TRUE	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
this	O	O
.	O	O
testRootDir	O	TRUE
+	O	O
+	O	O
)	O	O
;	O	O
long	O	O
fileSize	O	TRUE
=	O	O
5	O	O
*	O	O
Unit	O	TRUE
.	O	O
MB	O	TRUE
;	O	O
ContractTestUtils	O	TRUE
.	O	O
generateTestFile	O	TRUE
(	O	O
this	O	O
.	O	O
fs	O	TRUE
,	O	O
readTestFilePath	TRUE	TRUE
,	O	O
fileSize	O	TRUE
,	O	O
256	O	O
,	O	O
255	O	O
)	O	O
;	O	O

LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
readTestFilePath	O	TRUE
+	O	O
)	O	O
;	O	O
FSDataInputStream	O	TRUE
inputStream	O	TRUE
=	O	O
this	O	O
.	O	O
fs	O	TRUE
.	O	O
open	O	TRUE
(	O	O
readTestFilePath	O	TRUE
)	O	O
;	O	O
byte	O	O
[	O	O
]	O	O
buf	O	TRUE
=	O	O
new	O	O
byte	O	O
[	O	O
bufLen	O	TRUE
]	O	O
;	O	O
long	O	O
bytesRead	O	TRUE
=	O	O
0	O	O
;	O	O
while	O	O
(	O	O
bytesRead	O	TRUE
<	O	O
fileSize	O	TRUE
)	O	O
{	O	O
int	O	O
bytes	O	TRUE
=	O	O
0	O	O
;	O	O
if	O	O
(	O	O
fileSize	O	TRUE
-	O	O
bytesRead	O	TRUE
<	O	O
bufLen	O	TRUE
)	O	O
{	O	O
int	O	O
remaining	O	TRUE
=	O	O
(	O	O
int	O	O
)	O	O
(	O	O
fileSize	O	TRUE
-	O	O
bytesRead	O	TRUE
)	O	O
;	O	O
bytes	O	TRUE
=	O	O
inputStream	O	TRUE
.	O	O
read	O	TRUE
(	O	O
buf	O	TRUE
,	O	O
0	O	O
,	O	O
remaining	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
bytes	O	TRUE
=	O	O
inputStream	O	TRUE
.	O	O
read	O	TRUE
(	O	O
buf	O	TRUE
,	O	O
0	O	O
,	O	O
bufLen	O	TRUE
)	O	O
;	O	O
}	O	O
bytesRead	O	TRUE
+=	O	O
bytes	O	TRUE
;	O	O
if	O	O
(	O	O
bytesRead	O	TRUE
%	O	O
(	O	O
1	O	O
*	O	O
Unit	TRUE	TRUE
.	O	O
MB	O	O
)	O	O
==	O	O
0	O	O
)	O	O
{	O	O
int	O	O
available	O	TRUE
=	O	O
inputStream	O	TRUE
.	O	O
available	O	TRUE
(	O	O
)	O	O
;	O	O
assertTrue	O	TRUE
(	O	O
+	O	O
(	O	O
fileSize	O	TRUE
-	O	O
bytesRead	O	TRUE
)	O	O
+	O	O
+	O	O
available	O	TRUE
,	O	O
(	O	O
fileSize	O	TRUE
-	O	O
bytesRead	O	TRUE
)	O	O
==	O	O
available	O	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
doFilter	O	O
(	O	O
ServletRequest	O	O
request	O	TRUE
,	O	O
ServletResponse	O	O
response	O	TRUE
,	O	O
FilterChain	O	O
filterChain	O	O
)	O	O
throws	O	O
IOException	O	O
,	O	O
ServletException	O	O
{	O	O
boolean	O	O
unauthorizedResponse	O	TRUE
=	O	O
true	O	O
;	O	O
int	O	O
errCode	O	TRUE
=	O	O
HttpServletResponse	O	TRUE
.	O	O
SC_UNAUTHORIZED	O	TRUE
;	O	O
AuthenticationException	O	TRUE
authenticationEx	O	TRUE
=	O	O
null	O	O
;	O	O
HttpServletRequest	O	TRUE
httpRequest	TRUE	TRUE
=	O	O
(	O	O
HttpServletRequest	O	TRUE
)	O	O
request	O	TRUE
;	O	O
HttpServletResponse	O	TRUE
httpResponse	O	TRUE
=	O	O
(	O	O
HttpServletResponse	O	TRUE
)	O	O
response	O	TRUE
;	O	O
boolean	O	O
isHttps	O	TRUE
=	O	O
.	O	O
equals	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
.	O	O
getScheme	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
try	O	O
{	O	O
boolean	O	O
newToken	O	TRUE
=	O	O
false	O	O
;	O	O
AuthenticationToken	O	TRUE
token	TRUE	TRUE
;	O	O
try	O	O
{	O	O
token	TRUE	TRUE
=	O	O
getToken	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

boolean	O	O
isHttps	O	TRUE
=	O	O
.	O	O
equals	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
.	O	O
getScheme	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
try	O	O
{	O	O
boolean	O	O
newToken	O	TRUE
=	O	O
false	O	O
;	O	O
AuthenticationToken	O	TRUE
token	O	TRUE
;	O	O
try	O	O
{	O	O
token	O	TRUE
=	O	O
getToken	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
token	O	TRUE
,	O	O
getRequestURL	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
AuthenticationException	O	O
ex	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
ex	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
authenticationEx	O	TRUE
=	O	O
ex	O	TRUE
;	O	O
token	O	TRUE
=	O	O
null	O	O
;	O	O
}	O	O
if	O	O
(	O	O
authHandler	TRUE	TRUE
.	O	O
managementOperation	O	O
(	O	O
token	O	TRUE
,	O	O
httpRequest	TRUE	TRUE
,	O	O
httpResponse	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
token	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
ex	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
authenticationEx	O	TRUE
=	O	O
ex	O	TRUE
;	O	O
token	TRUE	TRUE
=	O	O
null	O	O
;	O	O
}	O	O
if	O	O
(	O	O
authHandler	O	TRUE
.	O	O
managementOperation	O	O
(	O	O
token	TRUE	TRUE
,	O	O
httpRequest	TRUE	TRUE
,	O	O
httpResponse	O	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
token	TRUE	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
getRequestURL	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
)	O	O
,	O	O
authHandler	O	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
token	TRUE	TRUE
=	O	O
authHandler	O	TRUE
.	O	O
authenticate	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
,	O	O
httpResponse	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
token	TRUE	TRUE
!=	O	O
null	O	O
&&	O	O
token	TRUE	TRUE
!=	O	O
AuthenticationToken	O	O
.	O	O
ANONYMOUS	O	O
)	O	O
{	O	O
if	O	O
(	O	O
token	TRUE	TRUE
.	O	O
getMaxInactives	O	O
(	O	O
)	O	O
>	O	O
0	O	O
)	O	O
{	O	O
token	TRUE	TRUE
.	O	O
setMaxInactives	O	TRUE
(	O	O
System	O	TRUE
.	O	O
currentTimeMillis	O	TRUE
(	O	O
)	O	O
+	O	O
getMaxInactiveInterval	O	TRUE
(	O	O
)	O	O
*	O	O
1000	O	O
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
token	TRUE	TRUE
.	O	O
getExpires	O	O
(	O	O
)	O	O
!=	O	O
0	O	O
)	O	O
{	O	O
token	TRUE	TRUE
.	O	O
setExpires	O	TRUE
(	O	O
System	O	TRUE
.	O	O
currentTimeMillis	O	TRUE
(	O	O
)	O	O
+	O	O
getValidity	O	TRUE
(	O	O
)	O	O
*	O	O
1000	O	O
)	O	O
;	O	O
}	O	O
}	O	O
newToken	O	TRUE
=	O	O
true	O	O
;	O	O
}	O	O
if	O	O
(	O	O
token	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O

if	O	O
(	O	O
token	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
unauthorizedResponse	O	TRUE
=	O	O
false	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
getRequestURL	O	TRUE
(	O	O
httpRequest	TRUE	TRUE
)	O	O
,	O	O
token	TRUE	TRUE
.	O	O
getUserName	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
final	O	O
AuthenticationToken	O	TRUE
authToken	O	TRUE
=	O	O
token	TRUE	TRUE
;	O	O
httpRequest	TRUE	TRUE
=	O	O
new	O	O
HttpServletRequestWrapper	O	O
(	O	O
httpRequest	TRUE	TRUE
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
String	O	O
getAuthType	O	O
(	O	O
)	O	O
{	O	O
return	O	O
authToken	O	TRUE
.	O	O
getType	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
@	O	O
Override	O	O
public	O	O
String	O	O
getRemoteUser	O	O
(	O	O
)	O	O
{	O	O
return	O	O
authToken	O	TRUE
.	O	O
getUserName	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
@	O	O
Override	O	O
public	O	O
Principal	O	O
getUserPrincipal	O	O
(	O	O
)	O	O
{	O	O
return	O	O
(	O	O
authToken	O	TRUE
!=	O	O
AuthenticationToken	O	TRUE
.	O	O
ANONYMOUS	O	TRUE
)	O	O
?	O	O
authToken	O	TRUE
:	O	O
null	O	O
;	O	O
}	O	O
}	O	O
;	O	O
if	O	O
(	O	O
!	O	O
newToken	O	O
&&	O	O
!	O	O
isCookiePersistent	O	O
(	O	O
)	O	O
&&	O	O
getMaxInactiveInterval	O	TRUE
(	O	O
)	O	O
>	O	O
0	O	O
)	O	O
{	O	O
token	TRUE	TRUE
.	O	O
setMaxInactives	O	TRUE
(	O	O
System	O	TRUE
.	O	O
currentTimeMillis	O	TRUE
(	O	O
)	O	O
+	O	O
getMaxInactiveInterval	O	TRUE
(	O	O
)	O	O
*	O	O
1000	O	O
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
AuthenticationToken	O	TRUE
alternateAuthenticate	O	O
(	O	O
HttpServletRequest	O	TRUE
request	O	TRUE
,	O	O
HttpServletResponse	O	O
response	O	O
)	O	O
throws	O	O
IOException	O	O
,	O	O
AuthenticationException	O	O
{	O	O
AuthenticationToken	O	TRUE
token	O	TRUE
=	O	O
null	O	O
;	O	O
String	O	TRUE
serializedJWT	O	TRUE
=	O	O
null	O	O
;	O	O
HttpServletRequest	O	TRUE
req	O	TRUE
=	O	O
(	O	O
HttpServletRequest	O	TRUE
)	O	O
request	O	TRUE
;	O	O
serializedJWT	O	TRUE
=	O	O
getJWTFromCookie	O	TRUE
(	O	O
req	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
serializedJWT	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
String	O	TRUE
loginURL	TRUE	TRUE
=	O	O
constructLoginURL	O	TRUE
(	O	O
request	O	TRUE
)	O	O
;	O	O

HttpServletRequest	O	TRUE
req	O	TRUE
=	O	O
(	O	O
HttpServletRequest	O	TRUE
)	O	O
request	O	TRUE
;	O	O
serializedJWT	O	TRUE
=	O	O
getJWTFromCookie	O	TRUE
(	O	O
req	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
serializedJWT	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
String	O	TRUE
loginURL	O	TRUE
=	O	O
constructLoginURL	O	TRUE
(	O	O
request	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
loginURL	O	TRUE
)	O	O
;	O	O
(	O	O
(	O	O
HttpServletResponse	O	TRUE
)	O	O
response	O	TRUE
)	O	O
.	O	O
sendRedirect	O	TRUE
(	O	O
loginURL	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
String	O	TRUE
userName	TRUE	TRUE
=	O	O
null	O	O
;	O	O
SignedJWT	O	TRUE
jwtToken	O	TRUE
=	O	O
null	O	O
;	O	O
boolean	O	O
valid	O	TRUE
=	O	O
false	O	O
;	O	O
try	O	O
{	O	O
jwtToken	O	TRUE
=	O	O
SignedJWT	O	TRUE
.	O	O
parse	O	TRUE
(	O	O
serializedJWT	O	TRUE
)	O	O
;	O	O
valid	O	TRUE
=	O	O
validateToken	O	TRUE
(	O	O
jwtToken	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
valid	O	TRUE
)	O	O
{	O	O
userName	TRUE	TRUE
=	O	O
jwtToken	O	TRUE
.	O	O
getJWTClaimsSet	O	TRUE
(	O	O
)	O	O
.	O	O
getSubject	O	TRUE
(	O	O
)	O	O
;	O	O

protected	O	O
String	O	TRUE
getJWTFromCookie	O	O
(	O	O
HttpServletRequest	O	O
req	O	TRUE
)	O	O
{	O	O
String	O	TRUE
serializedJWT	O	TRUE
=	O	O
null	O	O
;	O	O
Cookie	O	TRUE
[	O	O
]	O	O
cookies	O	TRUE
=	O	O
req	O	TRUE
.	O	O
getCookies	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
cookies	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
for	O	O
(	O	O
Cookie	O	TRUE
cookie	O	O
:	O	O
cookies	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
cookieName	TRUE	TRUE
.	O	O
equals	O	O
(	O	O
cookie	O	O
.	O	O
getName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O

if	O	O
(	O	O
keytab	TRUE	TRUE
==	O	O
null	O	O
||	O	O
keytab	TRUE	TRUE
.	O	O
trim	O	O
(	O	O
)	O	O
.	O	O
length	O	O
(	O	O
)	O	O
==	O	O
0	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
ServletException	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
File	O	TRUE
keytabFile	O	TRUE
=	O	O
new	O	O
File	O	TRUE
(	O	O
keytab	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
keytabFile	O	TRUE
.	O	O
exists	O	O
(	O	O
)	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
ServletException	O	TRUE
(	O	O
+	O	O
keytab	TRUE	TRUE
)	O	O
;	O	O
}	O	O
final	O	O
String	O	TRUE
[	O	O
]	O	O
spnegoPrincipals	O	TRUE
;	O	O
if	O	O
(	O	O
principal	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
)	O	O
{	O	O
spnegoPrincipals	O	TRUE
=	O	O
KerberosUtil	O	TRUE
.	O	O
getPrincipalNames	O	TRUE
(	O	O
keytab	TRUE	TRUE
,	O	O
Pattern	O	TRUE
.	O	O
compile	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
spnegoPrincipals	O	TRUE
.	O	O
length	O	O
==	O	O
0	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
ServletException	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
else	O	O
{	O	O
spnegoPrincipals	O	TRUE
=	O	O
new	O	O
String	O	TRUE
[	O	O
]	O	O
{	O	O
principal	O	TRUE
}	O	O
;	O	O
}	O	O
KeyTab	O	TRUE
keytabInstance	O	TRUE
=	O	O
KeyTab	O	TRUE
.	O	O
getInstance	O	TRUE
(	O	O
keytabFile	O	TRUE
)	O	O
;	O	O
serverSubject	O	TRUE
.	O	O
getPrivateCredentials	O	TRUE
(	O	O
)	O	O
.	O	O
add	O	TRUE
(	O	O
keytabInstance	O	TRUE
)	O	O
;	O	O
for	O	O
(	O	O
String	O	TRUE
spnegoPrincipal	O	O
:	O	O
spnegoPrincipals	O	TRUE
)	O	O
{	O	O

env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
INITIAL_CONTEXT_FACTORY	O	TRUE
,	O	O
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
PROVIDER_URL	O	TRUE
,	O	O
providerUrl	O	TRUE
)	O	O
;	O	O
try	O	O
{	O	O
ctx	O	TRUE
=	O	O
new	O	O
InitialLdapContext	O	TRUE
(	O	O
env	O	TRUE
,	O	O
null	O	O
)	O	O
;	O	O
StartTlsResponse	O	TRUE
tls	O	TRUE
=	O	O
(	O	O
StartTlsResponse	O	TRUE
)	O	O
ctx	O	TRUE
.	O	O
extendedOperation	O	TRUE
(	O	O
new	O	O
StartTlsRequest	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
disableHostNameVerification	O	O
)	O	O
{	O	O
tls	O	TRUE
.	O	O
setHostnameVerifier	O	O
(	O	O
new	O	O
HostnameVerifier	O	O
(	O	O
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
boolean	O	O
verify	O	O
(	O	O
String	O	O
hostname	O	O
,	O	O
SSLSession	O	O
session	O	O
)	O	O
{	O	O
return	O	O
true	O	O
;	O	O
}	O	O
}	O	O
)	O	O
;	O	O
}	O	O
tls	O	TRUE
.	O	O
negotiate	O	TRUE
(	O	O
)	O	O
;	O	O
ctx	O	TRUE
.	O	O
addToEnvironment	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_AUTHENTICATION	O	TRUE
,	O	O
SECURITY_AUTHENTICATION	O	TRUE
)	O	O
;	O	O
ctx	O	TRUE
.	O	O
addToEnvironment	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_PRINCIPAL	O	TRUE
,	O	O
userDN	TRUE	TRUE
)	O	O
;	O	O
ctx	O	TRUE
.	O	O
addToEnvironment	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_CREDENTIALS	O	TRUE
,	O	O
password	O	TRUE
)	O	O
;	O	O
ctx	O	TRUE
.	O	O
lookup	O	TRUE
(	O	O
userDN	TRUE	TRUE
)	O	O
;	O	O

private	O	O
void	O	O
authenticateWithoutTlsExtension	O	O
(	O	O
String	O	TRUE
userDN	TRUE	TRUE
,	O	O
String	O	TRUE
password	O	TRUE
)	O	O
throws	O	O
AuthenticationException	O	O
{	O	O
Hashtable	O	TRUE
<	O	O
String	O	TRUE
,	O	O
Object	O	TRUE
>	O	O
env	O	TRUE
=	O	O
new	O	O
Hashtable	O	TRUE
<	O	O
String	O	TRUE
,	O	O
Object	O	TRUE
>	O	O
(	O	O
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
INITIAL_CONTEXT_FACTORY	O	TRUE
,	O	O
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
PROVIDER_URL	O	TRUE
,	O	O
providerUrl	O	TRUE
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_AUTHENTICATION	O	TRUE
,	O	O
SECURITY_AUTHENTICATION	O	TRUE
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_PRINCIPAL	O	TRUE
,	O	O
userDN	TRUE	TRUE
)	O	O
;	O	O
env	O	TRUE
.	O	O
put	O	TRUE
(	O	O
Context	O	TRUE
.	O	O
SECURITY_CREDENTIALS	O	TRUE
,	O	O
password	O	TRUE
)	O	O
;	O	O
try	O	O
{	O	O
Context	O	TRUE
ctx	O	TRUE
=	O	O
new	O	O
InitialDirContext	O	TRUE
(	O	O
env	O	TRUE
)	O	O
;	O	O
ctx	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
init	O	O
(	O	O
Properties	O	O
config	O	O
)	O	O
throws	O	O
ServletException	O	O
{	O	O
for	O	O
(	O	O
Map	O	O
.	O	O
Entry	O	O
prop	TRUE	TRUE
:	O	O
config	O	O
.	O	O
entrySet	O	O
(	O	O
)	O	O
)	O	O
{	O	O

protected	O	O
AuthenticationHandler	O	O
initializeAuthHandler	O	O
(	O	O
String	O	O
authHandlerClassName	TRUE	TRUE
,	O	O
Properties	O	O
config	O	O
)	O	O
throws	O	O
ServletException	O	O
{	O	O
try	O	O
{	O	O
Preconditions	O	TRUE
.	O	O
checkNotNull	O	TRUE
(	O	O
authHandlerClassName	TRUE	TRUE
)	O	O
;	O	O

protected	O	O
AuthenticationHandler	O	TRUE
initializeAuthHandler	O	O
(	O	O
String	O	O
authHandlerClassName	TRUE	TRUE
,	O	O
Properties	O	O
config	O	TRUE
)	O	O
throws	O	O
ServletException	O	O
{	O	O
try	O	O
{	O	O
Preconditions	O	TRUE
.	O	O
checkNotNull	O	TRUE
(	O	O
authHandlerClassName	TRUE	TRUE
)	O	O
;	O	O
logger	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
authHandlerClassName	TRUE	TRUE
)	O	O
;	O	O
Class	O	TRUE
<	O	O
?	O	O
>	O	O
klass	O	TRUE
=	O	O
Thread	O	TRUE
.	O	O
currentThread	O	TRUE
(	O	O
)	O	O
.	O	O
getContextClassLoader	O	TRUE
(	O	O
)	O	O
.	O	O
loadClass	O	TRUE
(	O	O
authHandlerClassName	TRUE	TRUE
)	O	O
;	O	O
AuthenticationHandler	O	TRUE
authHandler	O	TRUE
=	O	O
(	O	O
AuthenticationHandler	O	TRUE
)	O	O
klass	O	TRUE
.	O	O
newInstance	O	TRUE
(	O	O
)	O	O
;	O	O
authHandler	O	TRUE
.	O	O
init	O	TRUE
(	O	O
config	O	TRUE
)	O	O
;	O	O

@	O	O
VisibleForTesting	O	O
void	O	O
logDeprecation	O	O
(	O	O
String	O	O
message	TRUE	TRUE
)	O	O
{	O	O

void	O	O
logDeprecationOnce	O	O
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
String	O	O
source	TRUE	TRUE
)	O	O
{	O	O
DeprecatedKeyInfo	O	TRUE
keyInfo	O	TRUE
=	O	O
getDeprecatedKeyInfo	O	TRUE
(	O	O
name	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
keyInfo	O	TRUE
!=	O	O
null	O	O
&&	O	O
!	O	O
keyInfo	O	TRUE
.	O	O
getAndSetAccessed	O	O
(	O	O
)	O	O
)	O	O
{	O	O

public	O	O
InputStream	O	O
getConfResourceAsInputStream	O	O
(	O	O
String	O	O
name	TRUE	TRUE
)	O	O
{	O	O
try	O	O
{	O	O
URL	O	TRUE
url	O	TRUE
=	O	O
getResource	O	TRUE
(	O	O
name	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
url	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O

public	O	O
Reader	O	O
getConfResourceAsReader	O	O
(	O	O
String	O	O
name	TRUE	TRUE
)	O	O
{	O	O
try	O	O
{	O	O
URL	O	TRUE
url	O	TRUE
=	O	O
getResource	O	TRUE
(	O	O
name	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
url	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O

private	O	O
XMLStreamReader	O	O
parse	O	O
(	O	O
URL	O	O
url	TRUE	TRUE
,	O	O
boolean	O	O
restricted	O	O
)	O	O
throws	O	O
IOException	O	O
,	O	O
XMLStreamException	O	O
{	O	O
if	O	O
(	O	O
!	O	O
quietmode	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
XMLStreamReader	O	O
parse	O	O
(	O	O
InputStream	O	O
is	TRUE	TRUE
,	O	O
String	O	O
systemIdStr	O	O
,	O	O
boolean	O	O
restricted	O	O
)	O	O
throws	O	O
IOException	O	O
,	O	O
XMLStreamException	O	O
{	O	O
if	O	O
(	O	O
!	O	O
quietmode	O	O
)	O	O
{	O	O

XMLStreamReader2	O	TRUE
reader	O	TRUE
=	O	O
getStreamReader	O	TRUE
(	O	O
wrapper	O	TRUE
,	O	O
quiet	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
reader	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
quiet	O	TRUE
)	O	O
{	O	O
return	O	O
null	O	O
;	O	O
}	O	O
throw	O	O
new	O	O
RuntimeException	O	TRUE
(	O	O
resource	O	TRUE
+	O	O
)	O	O
;	O	O
}	O	O
Properties	O	TRUE
toAddTo	O	TRUE
=	O	O
properties	O	TRUE
;	O	O
if	O	O
(	O	O
returnCachedProperties	O	O
)	O	O
{	O	O
toAddTo	O	TRUE
=	O	O
new	O	O
Properties	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
List	O	TRUE
<	O	O
ParsedItem	O	TRUE
>	O	O
items	O	TRUE
=	O	O
new	O	O
Parser	O	TRUE
(	O	O
reader	O	TRUE
,	O	O
wrapper	O	TRUE
,	O	O
quiet	O	TRUE
)	O	O
.	O	O
parse	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
ParsedItem	O	TRUE
item	O	TRUE
:	O	O
items	O	TRUE
)	O	O
{	O	O
loadProperty	O	TRUE
(	O	O
toAddTo	O	TRUE
,	O	O
item	O	TRUE
.	O	O
name	TRUE	TRUE
,	O	O
item	O	TRUE
.	O	O
key	O	TRUE
,	O	O
item	O	TRUE
.	O	O
value	O	TRUE
,	O	O
item	O	TRUE
.	O	O
isFinal	O	TRUE
,	O	O
item	O	TRUE
.	O	O
sources	O	TRUE
)	O	O
;	O	O
}	O	O
reader	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
returnCachedProperties	O	O
)	O	O
{	O	O
overlay	O	TRUE
(	O	O
properties	O	TRUE
,	O	O
toAddTo	O	TRUE
)	O	O
;	O	O
return	O	O
new	O	O
Resource	O	TRUE
(	O	O
toAddTo	O	TRUE
,	O	O
name	TRUE	TRUE
,	O	O
wrapper	O	TRUE
.	O	O
isParserRestricted	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

return	O	O
null	O	O
;	O	O
}	O	O
throw	O	O
new	O	O
RuntimeException	O	TRUE
(	O	O
resource	O	TRUE
+	O	O
)	O	O
;	O	O
}	O	O
Properties	O	TRUE
toAddTo	O	TRUE
=	O	O
properties	O	TRUE
;	O	O
if	O	O
(	O	O
returnCachedProperties	O	O
)	O	O
{	O	O
toAddTo	O	TRUE
=	O	O
new	O	O
Properties	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
List	O	TRUE
<	O	O
ParsedItem	O	TRUE
>	O	O
items	O	TRUE
=	O	O
new	O	O
Parser	O	TRUE
(	O	O
reader	O	TRUE
,	O	O
wrapper	O	TRUE
,	O	O
quiet	O	TRUE
)	O	O
.	O	O
parse	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
ParsedItem	O	TRUE
item	O	TRUE
:	O	O
items	O	TRUE
)	O	O
{	O	O
loadProperty	O	TRUE
(	O	O
toAddTo	O	TRUE
,	O	O
item	O	TRUE
.	O	O
name	TRUE	TRUE
,	O	O
item	O	TRUE
.	O	O
key	O	TRUE
,	O	O
item	O	TRUE
.	O	O
value	O	TRUE
,	O	O
item	O	TRUE
.	O	O
isFinal	O	TRUE
,	O	O
item	O	TRUE
.	O	O
sources	O	TRUE
)	O	O
;	O	O
}	O	O
reader	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
returnCachedProperties	O	O
)	O	O
{	O	O
overlay	O	TRUE
(	O	O
properties	O	TRUE
,	O	O
toAddTo	O	TRUE
)	O	O
;	O	O
return	O	O
new	O	O
Resource	O	TRUE
(	O	O
toAddTo	O	TRUE
,	O	O
name	TRUE	TRUE
,	O	O
wrapper	O	TRUE
.	O	O
isParserRestricted	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
return	O	O
null	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
name	TRUE	TRUE
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
String	O	TRUE
get	O	TRUE
(	O	O
String	O	TRUE
name	TRUE	TRUE
)	O	O
{	O	O
String	O	TRUE
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
get	O	TRUE
(	O	O
name	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
String	O	TRUE
get	O	TRUE
(	O	O
String	O	TRUE
name	TRUE	TRUE
,	O	O
String	O	TRUE
defaultValue	TRUE	TRUE
)	O	O
{	O	O
String	O	TRUE
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
get	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
defaultValue	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
boolean	O	O
getBoolean	O	TRUE
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
boolean	O	O
defaultValue	TRUE	TRUE
)	O	O
{	O	O
boolean	O	O
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
getBoolean	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
defaultValue	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
float	O	O
getFloat	O	TRUE
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
float	O	O
defaultValue	TRUE	TRUE
)	O	O
{	O	O
float	O	O
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
getFloat	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
defaultValue	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
int	O	O
getInt	O	TRUE
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
int	O	O
defaultValue	TRUE	TRUE
)	O	O
{	O	O
int	O	O
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
getInt	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
defaultValue	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
long	O	O
getLong	O	TRUE
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
long	O	O
defaultValue	TRUE	TRUE
)	O	O
{	O	O
long	O	O
value	TRUE	TRUE
=	O	O
super	O	O
.	O	O
getLong	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
defaultValue	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
set	O	O
(	O	O
String	O	O
name	TRUE	TRUE
,	O	O
String	O	O
value	TRUE	TRUE
,	O	O
String	O	O
source	TRUE	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
final	O	O
void	O	O
reconfigureProperty	O	O
(	O	O
String	O	O
property	TRUE	TRUE
,	O	O
String	O	O
newVal	TRUE	TRUE
)	O	O
throws	O	O
ReconfigurationException	O	O
{	O	O
if	O	O
(	O	O
isPropertyReconfigurable	O	O
(	O	O
property	TRUE	TRUE
)	O	O
)	O	O
{	O	O

private	O	O
Reconfigurable	O	O
getReconfigurable	O	O
(	O	O
HttpServletRequest	O	O
req	TRUE	TRUE
)	O	O
{	O	O

private	O	O
Reconfigurable	O	O
getReconfigurable	O	O
(	O	O
HttpServletRequest	O	O
req	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
req	TRUE	TRUE
.	O	O
getServletPath	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

String	O	TRUE
rawParam	O	TRUE
=	O	O
params	O	TRUE
.	O	O
nextElement	O	TRUE
(	O	O
)	O	O
;	O	O
String	O	TRUE
param	TRUE	TRUE
=	O	O
StringEscapeUtils	O	TRUE
.	O	O
unescapeHtml4	O	TRUE
(	O	O
rawParam	O	TRUE
)	O	O
;	O	O
String	O	TRUE
value	O	TRUE
=	O	O
StringEscapeUtils	O	TRUE
.	O	O
unescapeHtml4	O	TRUE
(	O	O
req	O	TRUE
.	O	O
getParameter	O	TRUE
(	O	O
rawParam	O	TRUE
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
value	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
newConf	O	O
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
)	O	O
||	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
||	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
||	O	O
value	O	TRUE
.	O	O
isEmpty	O	O
(	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
(	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
||	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
||	O	O
value	O	TRUE
.	O	O
isEmpty	O	O
(	O	O
)	O	O
)	O	O
&&	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
out	O	TRUE
.	O	O
println	O	TRUE
(	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
+	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
)	O	O
+	O	O
)	O	O
;	O	O
reconf	O	TRUE
.	O	O
reconfigureProperty	O	TRUE
(	O	O
param	TRUE	TRUE
,	O	O
null	O	O
)	O	O
;	O	O
}	O	O
else	O	O
if	O	O
(	O	O
!	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
&&	O	O
!	O	O
value	O	TRUE
.	O	O
equals	O	O
(	O	O
)	O	O
&&	O	O
!	O	O
value	O	TRUE
.	O	O
isEmpty	O	O
(	O	O
)	O	O
&&	O	O
(	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
==	O	O
null	O	O
||	O	O
!	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
.	O	O
equals	O	O
(	O	O
value	O	TRUE
)	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
==	O	O
null	O	O
)	O	O
{	O	O
out	O	TRUE
.	O	O
println	O	TRUE
(	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
+	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
value	O	TRUE
)	O	O
+	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
out	O	TRUE
.	O	O
println	O	TRUE
(	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
+	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
oldConf	O	TRUE
.	O	O
getRaw	O	TRUE
(	O	O
param	TRUE	TRUE
)	O	O
)	O	O
+	O	O
+	O	O
StringEscapeUtils	O	TRUE
.	O	O
escapeHtml4	O	TRUE
(	O	O
value	O	TRUE
)	O	O
+	O	O
)	O	O
;	O	O
}	O	O
reconf	O	TRUE
.	O	O
reconfigureProperty	O	TRUE
(	O	O
param	TRUE	TRUE
,	O	O
value	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
setConf	O	O
(	O	O
Configuration	O	O
conf	O	TRUE
)	O	O
{	O	O
this	O	O
.	O	O
conf	O	TRUE
=	O	O
conf	O	TRUE
;	O	O
final	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
Random	O	TRUE
>	O	O
klass	TRUE	TRUE
=	O	O
conf	O	TRUE
.	O	O
getClass	O	TRUE
(	O	O
HADOOP_SECURITY_SECURE_RANDOM_IMPL_KEY	O	TRUE
,	O	O
OpensslSecureRandom	O	TRUE
.	O	O
class	O	O
,	O	O
Random	O	TRUE
.	O	O
class	O	O
)	O	O
;	O	O
try	O	O
{	O	O
random	O	TRUE
=	O	O
ReflectionUtils	O	TRUE
.	O	O
newInstance	O	TRUE
(	O	O
klass	TRUE	TRUE
,	O	O
conf	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
FsPermission	O	TRUE
loadAndReturnPerm	O	O
(	O	O
Path	O	O
pathToLoad	TRUE	TRUE
,	O	O
Path	O	O
pathToDelete	O	O
)	O	O
throws	O	O
NoSuchAlgorithmException	O	O
,	O	O
CertificateException	O	O
,	O	O
IOException	O	O
{	O	O
FsPermission	O	TRUE
perm	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
perm	O	TRUE
=	O	O
loadFromPath	O	TRUE
(	O	O
pathToLoad	TRUE	TRUE
,	O	O
password	O	TRUE
)	O	O
;	O	O
renameOrFail	O	TRUE
(	O	O
pathToLoad	TRUE	TRUE
,	O	O
path	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
<	O	O
T	O	TRUE
>	O	O
T	O	TRUE
call	O	O
(	O	O
HttpURLConnection	O	O
conn	TRUE	TRUE
,	O	O
Object	O	O
jsonOutput	O	TRUE
,	O	O
int	O	O
expectedResponse	O	O
,	O	O
Class	O	O
<	O	O
T	O	TRUE
>	O	O
klass	O	O
,	O	O
int	O	O
authRetryCount	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
T	O	TRUE
ret	O	TRUE
=	O	O
null	O	O
;	O	O
OutputStream	O	TRUE
os	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
if	O	O
(	O	O
jsonOutput	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
os	O	TRUE
=	O	O
conn	TRUE	TRUE
.	O	O
getOutputStream	O	TRUE
(	O	O
)	O	O
;	O	O
writeJson	O	TRUE
(	O	O
jsonOutput	O	TRUE
,	O	O
os	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ex	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
os	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
conn	TRUE	TRUE
.	O	O
disconnect	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
IOUtils	O	TRUE
.	O	O
closeStream	O	TRUE
(	O	O
conn	TRUE	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
throw	O	O
ex	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
(	O	O
conn	TRUE	TRUE
.	O	O
getResponseCode	O	O
(	O	O
)	O	O
==	O	O
HttpURLConnection	O	O
.	O	O
HTTP_FORBIDDEN	O	O
&&	O	O
(	O	O
conn	TRUE	TRUE
.	O	O
getResponseMessage	O	O
(	O	O
)	O	O
.	O	O
equals	O	O
(	O	O
ANONYMOUS_REQUESTS_DISALLOWED	O	O
)	O	O
||	O	O
conn	TRUE	TRUE
.	O	O
getResponseMessage	O	O
(	O	O
)	O	O
.	O	O
contains	O	O
(	O	O
INVALID_SIGNATURE	O	O
)	O	O
)	O	O
)	O	O
||	O	O
conn	TRUE	TRUE
.	O	O
getResponseCode	O	O
(	O	O
)	O	O
==	O	O
HttpURLConnection	O	O
.	O	O
HTTP_UNAUTHORIZED	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

@	O	O
VisibleForTesting	O	O
DelegationTokenAuthenticatedURL	O	O
createAuthenticatedURL	O	O
(	O	O
)	O	O
{	O	O
return	O	O
new	O	O
DelegationTokenAuthenticatedURL	O	O
(	O	O
configurator	O	O
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
org	O	O
.	O	O
apache	O	O
.	O	O
hadoop	O	O
.	O	O
security	O	O
.	O	O
token	O	O
.	O	O
Token	O	O
<	O	O
?	O	O
extends	O	O
TokenIdentifier	O	O
>	O	O
selectDelegationToken	O	O
(	O	O
URL	O	O
url	O	O
,	O	O
Credentials	O	O
creds	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

protected	O	O
static	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
selectDelegationToken	O	O
(	O	O
Credentials	O	O
creds	O	TRUE
,	O	O
Text	O	O
service	TRUE	TRUE
)	O	O
{	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
token	TRUE	TRUE
=	O	O
creds	O	TRUE
.	O	O
getToken	O	TRUE
(	O	O
service	TRUE	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
getDelegationToken	O	O
(	O	O
final	O	O
String	O	TRUE
renewer	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
final	O	O
URL	O	TRUE
url	TRUE	TRUE
=	O	O
createURL	O	TRUE
(	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
)	O	O
;	O	O
final	O	O
DelegationTokenAuthenticatedURL	O	TRUE
authUrl	O	TRUE
=	O	O
new	O	O
DelegationTokenAuthenticatedURL	O	TRUE
(	O	O
configurator	O	TRUE
)	O	O
;	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
token	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
final	O	O
String	O	TRUE
doAsUser	O	TRUE
=	O	O
getDoAsUser	O	TRUE
(	O	O
)	O	O
;	O	O
token	O	TRUE
=	O	O
getActualUgi	O	O
(	O	O
)	O	O
.	O	O
doAs	O	O
(	O	O
new	O	O
PrivilegedExceptionAction	O	O
<	O	O
Token	O	TRUE
<	O	O
?	O	O
>>	O	O
(	O	O
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
run	O	O
(	O	O
)	O	O
throws	O	O
Exception	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
long	O	O
renewDelegationToken	O	O
(	O	O
final	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
dToken	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
try	O	O
{	O	O
final	O	O
String	O	TRUE
doAsUser	TRUE	TRUE
=	O	O
getDoAsUser	O	TRUE
(	O	O
)	O	O
;	O	O
final	O	O
DelegationTokenAuthenticatedURL	O	TRUE
.	O	O
Token	O	TRUE
token	TRUE	TRUE
=	O	O
generateDelegationToken	O	TRUE
(	O	O
dToken	O	TRUE
)	O	O
;	O	O
final	O	O
URL	O	TRUE
url	TRUE	TRUE
=	O	O
createURL	O	TRUE
(	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
Void	O	O
cancelDelegationToken	O	O
(	O	O
final	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
dToken	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
try	O	O
{	O	O
final	O	O
String	O	TRUE
doAsUser	TRUE	TRUE
=	O	O
getDoAsUser	O	TRUE
(	O	O
)	O	O
;	O	O
final	O	O
DelegationTokenAuthenticatedURL	O	TRUE
.	O	O
Token	O	TRUE
token	O	TRUE
=	O	O
generateDelegationToken	O	TRUE
(	O	O
dToken	TRUE	TRUE
)	O	O
;	O	O
return	O	O
getActualUgi	O	O
(	O	O
)	O	O
.	O	O
doAs	O	O
(	O	O
new	O	O
PrivilegedExceptionAction	O	O
<	O	O
Void	O	O
>	O	O
(	O	O
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
Void	O	O
run	O	O
(	O	O
)	O	O
throws	O	O
Exception	O	O
{	O	O
final	O	O
URL	O	TRUE
url	TRUE	TRUE
=	O	O
createURL	O	TRUE
(	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
,	O	O
null	O	O
)	O	O
;	O	O

private	O	O
boolean	O	O
containsKmsDt	O	O
(	O	O
UserGroupInformation	O	O
ugi	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
Credentials	O	TRUE
creds	O	TRUE
=	O	O
ugi	TRUE	TRUE
.	O	O
getCredentials	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
creds	O	TRUE
.	O	O
getAllTokens	O	O
(	O	O
)	O	O
.	O	O
isEmpty	O	O
(	O	O
)	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
getDelegationToken	O	TRUE
(	O	O
String	O	O
renewer	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
return	O	O
doOp	O	O
(	O	O
new	O	O
ProviderCallable	O	O
<	O	O
Token	O	TRUE
<	O	O
?	O	O
>>	O	O
(	O	O
)	O	O
{	O	O
@	O	O
Override	O	O
public	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
call	O	O
(	O	O
KMSClientProvider	O	O
provider	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
Token	O	TRUE
<	O	O
?	O	O
>	O	O
token	TRUE	TRUE
=	O	O
provider	O	TRUE
.	O	O
getDelegationToken	O	TRUE
(	O	O
renewer	O	TRUE
)	O	O
;	O	O
token	TRUE	TRUE
.	O	O
setService	O	TRUE
(	O	O
dtService	O	TRUE
)	O	O
;	O	O

private	O	O
int	O	O
readChecksumChunk	O	O
(	O	O
byte	O	O
b	O	TRUE
[	O	O
]	O	O
,	O	O
final	O	O
int	O	O
off	TRUE	TRUE
,	O	O
final	O	O
int	O	O
len	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
count	O	TRUE
=	O	O
pos	O	TRUE
=	O	O
0	O	O
;	O	O
int	O	O
read	O	TRUE
=	O	O
0	O	O
;	O	O
boolean	O	O
retry	O	TRUE
=	O	O
true	O	O
;	O	O
int	O	O
retriesLeft	O	TRUE
=	O	O
numOfRetries	O	TRUE
;	O	O
do	O	O
{	O	O
retriesLeft	O	TRUE
--	O	O
;	O	O
try	O	O
{	O	O
read	O	TRUE
=	O	O
readChunk	O	TRUE
(	O	O
chunkPos	O	TRUE
,	O	O
b	O	TRUE
,	O	O
off	TRUE	TRUE
,	O	O
len	O	TRUE
,	O	O
checksum	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
read	O	TRUE
>	O	O
0	O	O
)	O	O
{	O	O
if	O	O
(	O	O
needChecksum	O	O
(	O	O
)	O	O
)	O	O
{	O	O
verifySums	O	TRUE
(	O	O
b	O	TRUE
,	O	O
off	TRUE	TRUE
,	O	O
read	O	TRUE
)	O	O
;	O	O
}	O	O
chunkPos	O	TRUE
+=	O	O
read	O	TRUE
;	O	O
}	O	O
retry	O	TRUE
=	O	O
false	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
ChecksumException	O	O
ce	TRUE	TRUE
)	O	O
{	O	O

private	O	O
static	O	O
void	O	O
loadFileSystems	O	O
(	O	O
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
)	O	O
;	O	O
synchronized	O	O
(	O	O
FileSystem	O	TRUE
.	O	O
class	O	O
)	O	O
{	O	O
if	O	O
(	O	O
!	O	O
FILE_SYSTEMS_LOADED	O	O
)	O	O
{	O	O
ServiceLoader	O	TRUE
<	O	O
FileSystem	O	TRUE
>	O	O
serviceLoader	O	TRUE
=	O	O
ServiceLoader	O	TRUE
.	O	O
load	O	TRUE
(	O	O
FileSystem	O	TRUE
.	O	O
class	O	O
)	O	O
;	O	O
Iterator	O	TRUE
<	O	O
FileSystem	O	TRUE
>	O	O
it	O	TRUE
=	O	O
serviceLoader	O	TRUE
.	O	O
iterator	O	TRUE
(	O	O
)	O	O
;	O	O
while	O	O
(	O	O
it	O	TRUE
.	O	O
hasNext	O	O
(	O	O
)	O	O
)	O	O
{	O	O
FileSystem	O	TRUE
fs	TRUE	TRUE
;	O	O
try	O	O
{	O	O
fs	TRUE	TRUE
=	O	O
it	O	TRUE
.	O	O
next	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O
SERVICE_FILE_SYSTEMS	O	TRUE
.	O	O
put	O	TRUE
(	O	O
fs	TRUE	TRUE
.	O	O
getScheme	O	TRUE
(	O	O
)	O	O
,	O	O
fs	TRUE	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOGGER	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
)	O	O
;	O	O
synchronized	O	O
(	O	O
FileSystem	O	TRUE
.	O	O
class	O	O
)	O	O
{	O	O
if	O	O
(	O	O
!	O	O
FILE_SYSTEMS_LOADED	O	O
)	O	O
{	O	O
ServiceLoader	O	TRUE
<	O	O
FileSystem	O	TRUE
>	O	O
serviceLoader	O	TRUE
=	O	O
ServiceLoader	O	TRUE
.	O	O
load	O	TRUE
(	O	O
FileSystem	O	TRUE
.	O	O
class	O	O
)	O	O
;	O	O
Iterator	O	TRUE
<	O	O
FileSystem	O	TRUE
>	O	O
it	O	TRUE
=	O	O
serviceLoader	O	TRUE
.	O	O
iterator	O	TRUE
(	O	O
)	O	O
;	O	O
while	O	O
(	O	O
it	O	TRUE
.	O	O
hasNext	O	O
(	O	O
)	O	O
)	O	O
{	O	O
FileSystem	O	TRUE
fs	TRUE	TRUE
;	O	O
try	O	O
{	O	O
fs	TRUE	TRUE
=	O	O
it	O	TRUE
.	O	O
next	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O
SERVICE_FILE_SYSTEMS	O	TRUE
.	O	O
put	O	TRUE
(	O	O
fs	TRUE	TRUE
.	O	O
getScheme	O	TRUE
(	O	O
)	O	O
,	O	O
fs	TRUE	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOGGER	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
fs	TRUE	TRUE
.	O	O
getScheme	O	TRUE
(	O	O
)	O	O
,	O	O
fs	TRUE	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
,	O	O
ClassUtil	O	TRUE
.	O	O
findContainingJar	O	TRUE
(	O	O
fs	TRUE	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
,	O	O
fs	TRUE	TRUE
,	O	O
ClassUtil	O	TRUE
.	O	O
findContainingJar	O	TRUE
(	O	O
fs	TRUE	TRUE
.	O	O
getClass	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O

public	O	O
static	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
getFileSystemClass	O	O
(	O	O
String	O	TRUE
scheme	TRUE	TRUE
,	O	O
Configuration	O	O
conf	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
if	O	O
(	O	O
!	O	O
FILE_SYSTEMS_LOADED	O	O
)	O	O
{	O	O
loadFileSystems	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
clazz	O	TRUE
=	O	O
null	O	O
;	O	O
if	O	O
(	O	O
conf	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
String	O	TRUE
property	O	TRUE
=	O	O
+	O	O
scheme	TRUE	TRUE
+	O	O
;	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
property	O	TRUE
)	O	O
;	O	O
clazz	O	TRUE
=	O	O
(	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
)	O	O
conf	O	TRUE
.	O	O
getClass	O	TRUE
(	O	O
property	O	TRUE
,	O	O
null	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
clazz	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
)	O	O
;	O	O
clazz	O	TRUE
=	O	O
SERVICE_FILE_SYSTEMS	O	TRUE
.	O	O
get	O	TRUE
(	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O

LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
clazz	TRUE	TRUE
=	O	O
null	O	O
;	O	O
if	O	O
(	O	O
conf	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
String	O	TRUE
property	O	TRUE
=	O	O
+	O	O
scheme	TRUE	TRUE
+	O	O
;	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
property	O	TRUE
)	O	O
;	O	O
clazz	TRUE	TRUE
=	O	O
(	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
)	O	O
conf	O	TRUE
.	O	O
getClass	O	TRUE
(	O	O
property	O	TRUE
,	O	O
null	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
clazz	TRUE	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
)	O	O
;	O	O
clazz	TRUE	TRUE
=	O	O
SERVICE_FILE_SYSTEMS	O	TRUE
.	O	O
get	O	TRUE
(	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
scheme	TRUE	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
clazz	TRUE	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
UnsupportedFileSystemException	O	TRUE
(	O	O
+	O	O
+	O	O
scheme	TRUE	TRUE
+	O	O
)	O	O
;	O	O

private	O	O
static	O	O
void	O	O
runCommandOnStream	O	O
(	O	O
InputStream	O	O
inputStream	O	O
,	O	O
String	O	TRUE
command	O	TRUE
)	O	O
throws	O	O
IOException	O	O
,	O	O
InterruptedException	O	O
,	O	O
ExecutionException	O	O
{	O	O
ExecutorService	O	TRUE
executor	O	TRUE
=	O	O
null	O	O
;	O	O
ProcessBuilder	O	TRUE
builder	O	TRUE
=	O	O
new	O	O
ProcessBuilder	O	TRUE
(	O	O
)	O	O
;	O	O
builder	O	TRUE
.	O	O
command	O	TRUE
(	O	O
Shell	O	TRUE
.	O	O
WINDOWS	O	TRUE
?	O	O
:	O	O
,	O	O
Shell	O	TRUE
.	O	O
WINDOWS	O	TRUE
?	O	O
:	O	O
,	O	O
command	O	TRUE
)	O	O
;	O	O
Process	O	TRUE
process	O	TRUE
=	O	O
builder	O	TRUE
.	O	O
start	O	TRUE
(	O	O
)	O	O
;	O	O
int	O	O
exitCode	O	TRUE
;	O	O
try	O	O
{	O	O
executor	O	TRUE
=	O	O
Executors	O	TRUE
.	O	O
newFixedThreadPool	O	TRUE
(	O	O
2	O	O
)	O	O
;	O	O
Future	O	O
output	O	O
=	O	O
executor	O	TRUE
.	O	O
submit	O	O
(	O	O
(	O	O
)	O	O
->	O	O
{	O	O
try	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
try	O	O
(	O	O
BufferedReader	O	O
reader	O	O
=	O	O
new	O	O
BufferedReader	O	O
(	O	O
new	O	O
InputStreamReader	O	O
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	O
(	O	O
)	O	O
,	O	O
Charset	O	O
.	O	O
forName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
)	O	O
{	O	O
String	O	TRUE
line	TRUE	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
line	TRUE	TRUE
=	O	O
reader	O	O
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O

builder	O	TRUE
.	O	O
command	O	TRUE
(	O	O
Shell	O	TRUE
.	O	O
WINDOWS	O	TRUE
?	O	O
:	O	O
,	O	O
Shell	O	TRUE
.	O	O
WINDOWS	O	TRUE
?	O	O
:	O	O
,	O	O
command	O	TRUE
)	O	O
;	O	O
Process	O	TRUE
process	O	TRUE
=	O	O
builder	O	TRUE
.	O	O
start	O	TRUE
(	O	O
)	O	O
;	O	O
int	O	O
exitCode	O	TRUE
;	O	O
try	O	O
{	O	O
executor	O	TRUE
=	O	O
Executors	O	TRUE
.	O	O
newFixedThreadPool	O	TRUE
(	O	O
2	O	O
)	O	O
;	O	O
Future	O	O
output	O	O
=	O	O
executor	O	TRUE
.	O	O
submit	O	O
(	O	O
(	O	O
)	O	O
->	O	O
{	O	O
try	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
try	O	O
(	O	O
BufferedReader	O	O
reader	O	O
=	O	O
new	O	O
BufferedReader	O	O
(	O	O
new	O	O
InputStreamReader	O	O
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
,	O	O
Charset	O	O
.	O	O
forName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
)	O	O
{	O	O
String	O	TRUE
line	O	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
line	O	TRUE
=	O	O
reader	O	O
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
line	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
else	O	O
{	O	O
org	O	TRUE
.	O	O
apache	O	TRUE
.	O	O
commons	O	TRUE
.	O	O
io	O	TRUE
.	O	O
IOUtils	O	TRUE
.	O	O
copy	O	TRUE
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
,	O	O
new	O	O
IOUtils	O	TRUE
.	O	O
NullOutputStream	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

try	O	O
(	O	O
BufferedReader	O	O
reader	O	O
=	O	O
new	O	O
BufferedReader	O	O
(	O	O
new	O	O
InputStreamReader	O	O
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
,	O	O
Charset	O	O
.	O	O
forName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
)	O	O
{	O	O
String	O	TRUE
line	TRUE	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
line	TRUE	TRUE
=	O	O
reader	O	O
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
line	TRUE	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
else	O	O
{	O	O
org	O	TRUE
.	O	O
apache	O	TRUE
.	O	O
commons	O	TRUE
.	O	O
io	O	TRUE
.	O	O
IOUtils	O	TRUE
.	O	O
copy	O	TRUE
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
,	O	O
new	O	O
IOUtils	O	TRUE
.	O	O
NullOutputStream	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
e	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
)	O	O
;	O	O
Future	O	O
error	O	O
=	O	O
executor	O	O
.	O	O
submit	O	O
(	O	O
(	O	O
)	O	O
->	O	O
{	O	O
try	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
try	O	O
(	O	O
BufferedReader	O	O
reader	O	O
=	O	O
new	O	O
BufferedReader	O	O
(	O	O
new	O	O
InputStreamReader	O	O
(	O	O
process	O	TRUE
.	O	O
getErrorStream	O	O
(	O	O
)	O	O
,	O	O
Charset	O	O
.	O	O
forName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
)	O	O
{	O	O
String	O	TRUE
line	TRUE	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
line	TRUE	TRUE
=	O	O
reader	O	O
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O

}	O	O
}	O	O
}	O	O
else	O	O
{	O	O
org	O	TRUE
.	O	O
apache	O	TRUE
.	O	O
commons	O	TRUE
.	O	O
io	O	TRUE
.	O	O
IOUtils	O	TRUE
.	O	O
copy	O	TRUE
(	O	O
process	O	TRUE
.	O	O
getInputStream	O	TRUE
(	O	O
)	O	O
,	O	O
new	O	O
IOUtils	O	TRUE
.	O	O
NullOutputStream	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
e	TRUE	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
)	O	O
;	O	O
Future	O	O
error	O	O
=	O	O
executor	O	O
.	O	O
submit	O	O
(	O	O
(	O	O
)	O	O
->	O	O
{	O	O
try	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
try	O	O
(	O	O
BufferedReader	O	O
reader	O	O
=	O	O
new	O	O
BufferedReader	O	O
(	O	O
new	O	O
InputStreamReader	O	O
(	O	O
process	O	TRUE
.	O	O
getErrorStream	O	TRUE
(	O	O
)	O	O
,	O	O
Charset	O	O
.	O	O
forName	O	O
(	O	O
)	O	O
)	O	O
)	O	O
)	O	O
{	O	O
String	O	TRUE
line	O	TRUE
;	O	O
while	O	O
(	O	O
(	O	O
line	O	TRUE
=	O	O
reader	O	O
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
line	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
else	O	O
{	O	O
org	O	TRUE
.	O	O
apache	O	TRUE
.	O	O
commons	O	TRUE
.	O	O
io	O	TRUE
.	O	O
IOUtils	O	TRUE
.	O	O
copy	O	TRUE
(	O	O
process	O	TRUE
.	O	O
getErrorStream	O	TRUE
(	O	O
)	O	O
,	O	O
new	O	O
IOUtils	O	TRUE
.	O	O
NullOutputStream	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

ShellCommandExecutor	O	TRUE
shExec	O	TRUE
;	O	O
try	O	O
{	O	O
if	O	O
(	O	O
Shell	O	O
.	O	O
WINDOWS	O	O
&&	O	O
linkFile	O	TRUE
.	O	O
getParentFile	O	TRUE
(	O	O
)	O	O
!=	O	O
null	O	O
&&	O	O
!	O	O
new	O	O
Path	O	O
(	O	O
target	TRUE	TRUE
)	O	O
.	O	O
isAbsolute	O	O
(	O	O
)	O	O
)	O	O
{	O	O
shExec	O	TRUE
=	O	O
new	O	O
ShellCommandExecutor	O	TRUE
(	O	O
cmd	O	TRUE
,	O	O
linkFile	O	TRUE
.	O	O
getParentFile	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
shExec	O	TRUE
=	O	O
new	O	O
ShellCommandExecutor	O	TRUE
(	O	O
cmd	O	TRUE
)	O	O
;	O	O
}	O	O
shExec	O	TRUE
.	O	O
execute	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Shell	O	O
.	O	O
ExitCodeException	O	O
ec	O	TRUE
)	O	O
{	O	O
int	O	O
returnVal	O	TRUE
=	O	O
ec	O	TRUE
.	O	O
getExitCode	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
Shell	O	O
.	O	O
WINDOWS	O	O
&&	O	O
returnVal	O	TRUE
==	O	O
SYMLINK_NO_PRIVILEGE	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
+	O	O
+	O	O
)	O	O
;	O	O
}	O	O
else	O	O
if	O	O
(	O	O
returnVal	O	TRUE
!=	O	O
0	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
StringUtils	O	TRUE
.	O	O
join	O	TRUE
(	O	O
,	O	O
cmd	O	TRUE
)	O	O
+	O	O
+	O	O
returnVal	O	TRUE
+	O	O
+	O	O
ec	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
return	O	O
returnVal	O	TRUE
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

URI	O	TRUE
srcUri	O	TRUE
=	O	O
srcFs	O	TRUE
.	O	O
getUri	O	TRUE
(	O	O
)	O	O
;	O	O
URI	O	TRUE
dstUri	O	TRUE
=	O	O
destFs	O	TRUE
.	O	O
getUri	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
srcUri	O	TRUE
.	O	O
getScheme	O	O
(	O	O
)	O	O
==	O	O
null	O	O
)	O	O
{	O	O
return	O	O
false	O	O
;	O	O
}	O	O
if	O	O
(	O	O
!	O	O
srcUri	O	TRUE
.	O	O
getScheme	O	O
(	O	O
)	O	O
.	O	O
equals	O	O
(	O	O
dstUri	O	TRUE
.	O	O
getScheme	O	O
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O
return	O	O
false	O	O
;	O	O
}	O	O
String	O	TRUE
srcHost	O	TRUE
=	O	O
srcUri	O	TRUE
.	O	O
getHost	O	TRUE
(	O	O
)	O	O
;	O	O
String	O	TRUE
dstHost	O	TRUE
=	O	O
dstUri	O	TRUE
.	O	O
getHost	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
(	O	O
srcHost	O	TRUE
!=	O	O
null	O	O
)	O	O
&&	O	O
(	O	O
dstHost	O	TRUE
!=	O	O
null	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
srcHost	O	TRUE
.	O	O
equals	O	O
(	O	O
dstHost	O	TRUE
)	O	O
)	O	O
{	O	O
return	O	O
srcUri	O	TRUE
.	O	O
getPort	O	TRUE
(	O	O
)	O	O
==	O	O
dstUri	O	TRUE
.	O	O
getPort	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
try	O	O
{	O	O
srcHost	O	TRUE
=	O	O
InetAddress	O	TRUE
.	O	O
getByName	O	TRUE
(	O	O
srcHost	O	TRUE
)	O	O
.	O	O
getCanonicalHostName	O	TRUE
(	O	O
)	O	O
;	O	O
dstHost	O	TRUE
=	O	O
InetAddress	O	TRUE
.	O	O
getByName	O	TRUE
(	O	O
dstHost	O	TRUE
)	O	O
.	O	O
getCanonicalHostName	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
UnknownHostException	O	O
ue	TRUE	TRUE
)	O	O
{	O	O

if	O	O
(	O	O
args	O	TRUE
.	O	O
length	O	TRUE
(	O	O
)	O	O
>	O	O
2048	O	O
)	O	O
{	O	O
args	O	TRUE
=	O	O
args	O	TRUE
.	O	O
substring	O	TRUE
(	O	O
0	O	O
,	O	O
2048	O	O
)	O	O
;	O	O
}	O	O
scope	O	TRUE
.	O	O
getSpan	O	TRUE
(	O	O
)	O	O
.	O	O
addKVAnnotation	O	TRUE
(	O	O
,	O	O
args	O	TRUE
)	O	O
;	O	O
}	O	O
try	O	O
{	O	O
exitCode	O	TRUE
=	O	O
instance	O	TRUE
.	O	O
run	O	TRUE
(	O	O
Arrays	O	TRUE
.	O	O
copyOfRange	O	TRUE
(	O	O
argv	O	TRUE
,	O	O
1	O	O
,	O	O
argv	O	TRUE
.	O	O
length	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
finally	O	O
{	O	O
scope	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IllegalArgumentException	O	O
e	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
e	TRUE	TRUE
.	O	O
getMessage	O	O
(	O	O
)	O	O
==	O	O
null	O	O
)	O	O
{	O	O
displayError	O	TRUE
(	O	O
cmd	O	TRUE
,	O	O
)	O	O
;	O	O
e	TRUE	TRUE
.	O	O
printStackTrace	O	TRUE
(	O	O
System	O	TRUE
.	O	O
err	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
displayError	O	TRUE
(	O	O
cmd	O	TRUE
,	O	O
e	TRUE	TRUE
.	O	O
getLocalizedMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
printUsage	O	TRUE
(	O	O
System	O	TRUE
.	O	O
err	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
instance	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
java	O	O
.	O	O
net	O	O
.	O	O
URLStreamHandler	O	O
createURLStreamHandler	O	O
(	O	O
String	O	O
protocol	TRUE	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
java	O	O
.	O	O
net	O	O
.	O	O
URLStreamHandler	O	O
createURLStreamHandler	O	O
(	O	O
String	O	O
protocol	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
protocol	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
protocols	O	O
.	O	O
containsKey	O	O
(	O	O
protocol	TRUE	TRUE
)	O	O
)	O	O
{	O	O
boolean	O	O
known	O	TRUE
=	O	O
true	O	O
;	O	O
try	O	O
{	O	O
Class	O	TRUE
<	O	O
?	O	O
extends	O	O
FileSystem	O	TRUE
>	O	O
impl	TRUE	TRUE
=	O	O
FileSystem	O	TRUE
.	O	O
getFileSystemClass	O	TRUE
(	O	O
protocol	TRUE	TRUE
,	O	O
conf	O	TRUE
)	O	O
;	O	O

private	O	O
FileStatus	O	O
[	O	O
]	O	O
doGlob	O	O
(	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
String	O	TRUE
scheme	O	TRUE
=	O	O
schemeFromPath	O	TRUE
(	O	O
pathPattern	O	TRUE
)	O	O
;	O	O
String	O	TRUE
authority	O	TRUE
=	O	O
authorityFromPath	O	TRUE
(	O	O
pathPattern	O	TRUE
)	O	O
;	O	O
String	O	TRUE
pathPatternString	TRUE	TRUE
=	O	O
pathPattern	O	TRUE
.	O	O
toUri	O	TRUE
(	O	O
)	O	O
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
List	O	TRUE
<	O	O
String	O	TRUE
>	O	O
flattenedPatterns	O	TRUE
=	O	O
GlobExpander	O	TRUE
.	O	O
expand	O	TRUE
(	O	O
pathPatternString	TRUE	TRUE
)	O	O
;	O	O

private	O	O
FileStatus	O	TRUE
[	O	O
]	O	O
doGlob	O	O
(	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
String	O	TRUE
scheme	O	TRUE
=	O	O
schemeFromPath	O	TRUE
(	O	O
pathPattern	O	TRUE
)	O	O
;	O	O
String	O	TRUE
authority	O	TRUE
=	O	O
authorityFromPath	O	TRUE
(	O	O
pathPattern	O	TRUE
)	O	O
;	O	O
String	O	TRUE
pathPatternString	O	TRUE
=	O	O
pathPattern	O	TRUE
.	O	O
toUri	O	TRUE
(	O	O
)	O	O
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
List	O	TRUE
<	O	O
String	O	TRUE
>	O	O
flattenedPatterns	O	TRUE
=	O	O
GlobExpander	O	TRUE
.	O	O
expand	O	TRUE
(	O	O
pathPatternString	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
pathPatternString	O	TRUE
)	O	O
;	O	O
ArrayList	O	TRUE
<	O	O
FileStatus	O	TRUE
>	O	O
results	O	TRUE
=	O	O
new	O	O
ArrayList	O	TRUE
<	O	O
>	O	O
(	O	O
flattenedPatterns	O	TRUE
.	O	O
size	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
boolean	O	O
sawWildcard	O	TRUE
=	O	O
false	O	O
;	O	O
for	O	O
(	O	O
String	O	TRUE
flatPattern	O	TRUE
:	O	O
flattenedPatterns	O	TRUE
)	O	O
{	O	O
Path	O	TRUE
absPattern	TRUE	TRUE
=	O	O
fixRelativePart	O	TRUE
(	O	O
new	O	O
Path	O	TRUE
(	O	O
flatPattern	O	TRUE
.	O	O
isEmpty	O	TRUE
(	O	O
)	O	O
?	O	O
Path	O	TRUE
.	O	O
CUR_DIR	O	TRUE
:	O	O
flatPattern	O	TRUE
)	O	O
)	O	O
;	O	O

ArrayList	O	TRUE
<	O	O
FileStatus	O	TRUE
>	O	O
newCandidates	O	TRUE
=	O	O
new	O	O
ArrayList	O	TRUE
<	O	O
>	O	O
(	O	O
candidates	O	TRUE
.	O	O
size	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
GlobFilter	O	TRUE
globFilter	O	TRUE
=	O	O
new	O	O
GlobFilter	O	TRUE
(	O	O
components	O	TRUE
.	O	O
get	O	TRUE
(	O	O
componentIdx	O	TRUE
)	O	O
)	O	O
;	O	O
String	O	TRUE
component	O	TRUE
=	O	O
unescapePathComponent	O	TRUE
(	O	O
components	O	TRUE
.	O	O
get	O	TRUE
(	O	O
componentIdx	O	TRUE
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
globFilter	O	TRUE
.	O	O
hasPattern	O	O
(	O	O
)	O	O
)	O	O
{	O	O
sawWildcard	O	TRUE
=	O	O
true	O	O
;	O	O
}	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
component	O	TRUE
,	O	O
sawWildcard	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
candidates	O	TRUE
.	O	O
isEmpty	O	O
(	O	O
)	O	O
&&	O	O
sawWildcard	O	TRUE
)	O	O
{	O	O
break	O	O
;	O	O
}	O	O
if	O	O
(	O	O
(	O	O
componentIdx	O	TRUE
<	O	O
components	O	TRUE
.	O	O
size	O	TRUE
(	O	O
)	O	O
-	O	O
1	O	O
)	O	O
&&	O	O
(	O	O
!	O	O
globFilter	O	TRUE
.	O	O
hasPattern	O	O
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
candidate	O	TRUE
:	O	O
candidates	O	TRUE
)	O	O
{	O	O
candidate	O	TRUE
.	O	O
setPath	O	TRUE
(	O	O
new	O	O
Path	O	TRUE
(	O	O
candidate	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
,	O	O
component	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
continue	O	O
;	O	O
}	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
candidate	O	TRUE
:	O	O
candidates	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
globFilter	O	TRUE
.	O	O
hasPattern	O	O
(	O	O
)	O	O
)	O	O
{	O	O
FileStatus	O	TRUE
[	O	O
]	O	O
children	TRUE	TRUE
=	O	O
listStatus	O	TRUE
(	O	O
candidate	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

if	O	O
(	O	O
candidates	O	O
.	O	O
isEmpty	O	O
(	O	O
)	O	O
&&	O	O
sawWildcard	O	O
)	O	O
{	O	O
break	O	O
;	O	O
}	O	O
if	O	O
(	O	O
(	O	O
componentIdx	O	O
<	O	O
components	O	O
.	O	O
size	O	O
(	O	O
)	O	O
-	O	O
1	O	O
)	O	O
&&	O	O
(	O	O
!	O	O
globFilter	O	O
.	O	O
hasPattern	O	O
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
candidate	O	TRUE
:	O	O
candidates	O	O
)	O	O
{	O	O
candidate	O	TRUE
.	O	O
setPath	O	TRUE
(	O	O
new	O	O
Path	O	TRUE
(	O	O
candidate	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
,	O	O
component	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
continue	O	O
;	O	O
}	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
candidate	O	TRUE
:	O	O
candidates	O	O
)	O	O
{	O	O
if	O	O
(	O	O
globFilter	O	O
.	O	O
hasPattern	O	O
(	O	O
)	O	O
)	O	O
{	O	O
FileStatus	O	TRUE
[	O	O
]	O	O
children	O	TRUE
=	O	O
listStatus	O	TRUE
(	O	O
candidate	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
children	O	TRUE
.	O	O
length	O	O
==	O	O
1	O	O
)	O	O
{	O	O
if	O	O
(	O	O
resolveSymlinks	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
children	O	TRUE
[	O	O
0	O	O
]	O	O
)	O	O
;	O	O
Path	O	TRUE
path	O	TRUE
=	O	O
candidate	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
FileStatus	O	TRUE
status	TRUE	TRUE
=	O	O
getFileStatus	O	TRUE
(	O	O
path	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
status	TRUE	TRUE
==	O	O
null	O	O
)	O	O
{	O	O

@	O	O
VisibleForTesting	O	O
public	O	O
final	O	O
boolean	O	O
handleEmptyDstDirectoryOnWindows	O	O
(	O	O
Path	O	O
src	TRUE	TRUE
,	O	O
File	O	O
srcFile	O	O
,	O	O
Path	O	O
dst	TRUE	TRUE
,	O	O
File	O	O
dstFile	O	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O
try	O	O
{	O	O
FileStatus	O	TRUE
sdst	O	TRUE
=	O	O
this	O	O
.	O	O
getFileStatus	O	TRUE
(	O	O
dst	TRUE	TRUE
)	O	O
;	O	O
String	O	TRUE
[	O	O
]	O	O
dstFileList	O	TRUE
=	O	O
dstFile	O	TRUE
.	O	O
list	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
dstFileList	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
sdst	O	TRUE
.	O	O
isDirectory	O	O
(	O	O
)	O	O
&&	O	O
dstFileList	O	TRUE
.	O	O
length	O	O
==	O	O
0	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

}	O	O
}	O	O
catch	O	O
(	O	O
FileAlreadyExistsException	O	O
e	O	TRUE
)	O	O
{	O	O
Path	O	TRUE
existsFilePath	O	TRUE
=	O	O
baseTrashPath	O	TRUE
;	O	O
while	O	O
(	O	O
!	O	O
fs	O	O
.	O	O
exists	O	O
(	O	O
existsFilePath	O	TRUE
)	O	O
)	O	O
{	O	O
existsFilePath	O	TRUE
=	O	O
existsFilePath	O	TRUE
.	O	O
getParent	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
baseTrashPath	O	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
baseTrashPath	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
.	O	O
replace	O	TRUE
(	O	O
existsFilePath	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
,	O	O
existsFilePath	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
+	O	O
Time	O	TRUE
.	O	O
now	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O
trashPath	TRUE	TRUE
=	O	O
new	O	O
Path	O	TRUE
(	O	O
baseTrashPath	O	TRUE
,	O	O
trashPath	TRUE	TRUE
.	O	O
getName	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
--	O	O
i	O	TRUE
;	O	O
continue	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
baseTrashPath	O	TRUE
,	O	O
e	O	TRUE
)	O	O
;	O	O
cause	O	TRUE
=	O	O
e	O	TRUE
;	O	O
break	O	O
;	O	O
}	O	O
try	O	O
{	O	O
String	O	TRUE
orig	O	TRUE
=	O	O
trashPath	TRUE	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
;	O	O
while	O	O
(	O	O
fs	O	O
.	O	O
exists	O	O
(	O	O
trashPath	TRUE	TRUE
)	O	O
)	O	O
{	O	O

@	O	O
SuppressWarnings	O	O
(	O	O
)	O	O
public	O	O
void	O	O
createCheckpoint	O	O
(	O	O
Date	O	O
date	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
Collection	O	TRUE
<	O	O
FileStatus	O	TRUE
>	O	O
trashRoots	O	TRUE
=	O	O
fs	O	TRUE
.	O	O
getTrashRoots	O	TRUE
(	O	O
false	O	O
)	O	O
;	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
trashRoot	TRUE	TRUE
:	O	O
trashRoots	O	TRUE
)	O	O
{	O	O

private	O	O
void	O	O
deleteCheckpoint	O	O
(	O	O
boolean	O	O
deleteImmediately	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
Collection	O	TRUE
<	O	O
FileStatus	O	TRUE
>	O	O
trashRoots	O	TRUE
=	O	O
fs	O	TRUE
.	O	O
getTrashRoots	O	TRUE
(	O	O
false	O	O
)	O	O
;	O	O
for	O	O
(	O	O
FileStatus	O	TRUE
trashRoot	TRUE	TRUE
:	O	O
trashRoots	O	TRUE
)	O	O
{	O	O

private	O	O
void	O	O
deleteCheckpoint	O	O
(	O	O
Path	O	O
trashRoot	TRUE	TRUE
,	O	O
boolean	O	O
deleteImmediately	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O

return	O	O
;	O	O
}	O	O
long	O	O
now	O	TRUE
=	O	O
Time	O	TRUE
.	O	O
now	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
i	O	TRUE
<	O	O
dirs	O	TRUE
.	O	O
length	O	O
;	O	O
i	O	TRUE
++	O	O
)	O	O
{	O	O
Path	O	TRUE
path	O	TRUE
=	O	O
dirs	O	TRUE
[	O	O
i	O	TRUE
]	O	O
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
String	O	TRUE
dir	TRUE	TRUE
=	O	O
path	O	TRUE
.	O	O
toUri	O	TRUE
(	O	O
)	O	O
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
String	O	TRUE
name	O	TRUE
=	O	O
path	O	TRUE
.	O	O
getName	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
name	O	TRUE
.	O	O
equals	O	O
(	O	O
CURRENT	O	O
.	O	O
getName	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O
continue	O	O
;	O	O
}	O	O
long	O	O
time	O	TRUE
;	O	O
try	O	O
{	O	O
time	O	TRUE
=	O	O
getTimeFromCheckpoint	O	TRUE
(	O	O
name	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
ParseException	O	O
e	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
dir	TRUE	TRUE
+	O	O
)	O	O
;	O	O
continue	O	O
;	O	O
}	O	O
if	O	O
(	O	O
(	O	O
(	O	O
now	O	TRUE
-	O	O
deletionInterval	O	O
)	O	O
>	O	O
time	O	TRUE
)	O	O
||	O	O
deleteImmediately	O	O
)	O	O
{	O	O

continue	O	O
;	O	O
}	O	O
int	O	O
curVersion	O	TRUE
=	O	O
higherVersion	O	TRUE
;	O	O
try	O	O
{	O	O
curVersion	O	TRUE
=	O	O
Integer	O	TRUE
.	O	O
parseInt	O	TRUE
(	O	O
nameParts	O	TRUE
[	O	O
nameParts	O	TRUE
.	O	O
length	O	TRUE
-	O	O
2	O	O
]	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
NumberFormatException	O	O
nfe	O	O
)	O	O
{	O	O
logInvalidFileNameFormat	O	TRUE
(	O	O
cur	O	TRUE
)	O	O
;	O	O
continue	O	O
;	O	O
}	O	O
if	O	O
(	O	O
curVersion	O	TRUE
>	O	O
higherVersion	O	TRUE
)	O	O
{	O	O
higherVersion	O	TRUE
=	O	O
curVersion	O	TRUE
;	O	O
lfs	O	TRUE
=	O	O
curLfs	O	TRUE
;	O	O
}	O	O
}	O	O
if	O	O
(	O	O
lfs	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
LOGGER	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
+	O	O
,	O	O
mountTableConfigPath	O	TRUE
)	O	O
;	O	O
return	O	O
;	O	O
}	O	O
Path	O	TRUE
latestVersionMountTable	TRUE	TRUE
=	O	O
lfs	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOGGER	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

}	O	O
for	O	O
(	O	O
final	O	O
MRNflyNode	O	O
dstNode	TRUE	TRUE
:	O	O
mrNodes	O	O
)	O	O
{	O	O
if	O	O
(	O	O
dstNode	TRUE	TRUE
.	O	O
status	O	TRUE
==	O	O
null	O	O
||	O	O
srcNode	TRUE	TRUE
.	O	O
compareTo	O	O
(	O	O
dstNode	TRUE	TRUE
)	O	O
==	O	O
0	O	O
)	O	O
{	O	O
continue	O	O
;	O	O
}	O	O
try	O	O
{	O	O
final	O	O
FileStatus	O	TRUE
srcStatus	O	TRUE
=	O	O
srcNode	TRUE	TRUE
.	O	O
cloneStatus	O	TRUE
(	O	O
)	O	O
;	O	O
srcStatus	O	TRUE
.	O	O
setPath	O	TRUE
(	O	O
f	TRUE	TRUE
)	O	O
;	O	O
final	O	O
Path	O	TRUE
tmpPath	O	TRUE
=	O	O
getNflyTmpPath	O	TRUE
(	O	O
f	TRUE	TRUE
)	O	O
;	O	O
FileUtil	O	TRUE
.	O	O
copy	O	TRUE
(	O	O
srcNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
,	O	O
srcStatus	O	TRUE
,	O	O
dstNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
,	O	O
tmpPath	O	TRUE
,	O	O
false	O	O
,	O	O
true	O	O
,	O	O
getConf	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
dstNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
delete	O	TRUE
(	O	O
f	TRUE	TRUE
,	O	O
false	O	O
)	O	O
;	O	O
if	O	O
(	O	O
dstNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
rename	O	O
(	O	O
tmpPath	O	TRUE
,	O	O
f	TRUE	TRUE
)	O	O
)	O	O
{	O	O
try	O	O
{	O	O
dstNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
setTimes	O	TRUE
(	O	O
f	TRUE	TRUE
,	O	O
srcNode	TRUE	TRUE
.	O	O
status	O	TRUE
.	O	O
getModificationTime	O	TRUE
(	O	O
)	O	O
,	O	O
srcNode	TRUE	TRUE
.	O	O
status	O	TRUE
.	O	O
getAccessTime	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
finally	O	O
{	O	O
srcStatus	O	TRUE
.	O	O
setPath	O	TRUE
(	O	O
dstNode	TRUE	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
makeQualified	O	TRUE
(	O	O
f	TRUE	TRUE
)	O	O
)	O	O
;	O	O
dstNode	TRUE	TRUE
.	O	O
status	O	TRUE
=	O	O
srcStatus	O	TRUE
;	O	O

dstNode	O	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
setTimes	O	TRUE
(	O	O
f	TRUE	TRUE
,	O	O
srcNode	O	TRUE
.	O	O
status	O	TRUE
.	O	O
getModificationTime	O	TRUE
(	O	O
)	O	O
,	O	O
srcNode	O	TRUE
.	O	O
status	O	TRUE
.	O	O
getAccessTime	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
finally	O	O
{	O	O
srcStatus	O	TRUE
.	O	O
setPath	O	TRUE
(	O	O
dstNode	O	TRUE
.	O	O
getFs	O	TRUE
(	O	O
)	O	O
.	O	O
makeQualified	O	TRUE
(	O	O
f	TRUE	TRUE
)	O	O
)	O	O
;	O	O
dstNode	O	TRUE
.	O	O
status	O	TRUE
=	O	O
srcStatus	O	TRUE
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
f	TRUE	TRUE
+	O	O
+	O	O
srcNode	O	TRUE
+	O	O
+	O	O
dstNode	O	TRUE
+	O	O
,	O	O
ioe	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
if	O	O
(	O	O
maxMtime	O	O
>	O	O
0	O	O
)	O	O
{	O	O
final	O	O
List	O	TRUE
<	O	O
MRNflyNode	O	TRUE
>	O	O
mrList	O	TRUE
=	O	O
new	O	O
ArrayList	O	TRUE
<	O	O
MRNflyNode	O	TRUE
>	O	O
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
final	O	O
MRNflyNode	O	TRUE
openNode	O	TRUE
:	O	O
mrNodes	O	O
)	O	O
{	O	O
if	O	O
(	O	O
openNode	O	TRUE
.	O	O
status	O	TRUE
!=	O	O
null	O	O
&&	O	O
openNode	O	TRUE
.	O	O
status	O	TRUE
.	O	O
getLen	O	O
(	O	O
)	O	O
>=	O	O
0L	O	O
)	O	O
{	O	O
if	O	O
(	O	O
openNode	O	TRUE
.	O	O
status	O	TRUE
.	O	O
getModificationTime	O	TRUE
(	O	O
)	O	O
==	O	O
maxMtime	O	O
)	O	O
{	O	O
mrList	O	TRUE
.	O	O
add	O	TRUE
(	O	O
openNode	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
final	O	O
MRNflyNode	O	TRUE
[	O	O
]	O	O
readNodes	O	TRUE
=	O	O
mrList	O	TRUE
.	O	O
toArray	O	TRUE
(	O	O
new	O	O
MRNflyNode	O	TRUE
[	O	O
0	O	O
]	O	O
)	O	O
;	O	O
topology	O	TRUE
.	O	O
sortByDistance	O	TRUE
(	O	O
myNode	O	TRUE
,	O	O
readNodes	O	TRUE
,	O	O
readNodes	O	TRUE
.	O	O
length	O	TRUE
)	O	O
;	O	O
for	O	O
(	O	O
final	O	O
MRNflyNode	O	TRUE
rNode	O	O
:	O	O
readNodes	O	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
initialize	O	O
(	O	O
URI	O	O
theUri	TRUE	TRUE
,	O	O
Configuration	O	O
conf	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
this	O	O
.	O	O
myUri	O	TRUE
=	O	O
theUri	TRUE	TRUE
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
synchronized	O	O
void	O	O
processResult	O	O
(	O	O
int	O	O
rc	TRUE	TRUE
,	O	O
String	O	O
path	TRUE	TRUE
,	O	O
Object	O	O
ctx	O	TRUE
,	O	O
String	O	O
name	O	O
)	O	O
{	O	O
if	O	O
(	O	O
isStaleClient	O	TRUE
(	O	O
ctx	O	TRUE
)	O	O
)	O	O
return	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
rc	O	TRUE
+	O	O
+	O	O
path	O	TRUE
+	O	O
+	O	O
zkConnectionState	O	TRUE
+	O	O
+	O	O
this	O	O
)	O	O
;	O	O
}	O	O
Code	O	TRUE
code	O	TRUE
=	O	O
Code	O	TRUE
.	O	O
get	O	TRUE
(	O	O
rc	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
isSuccess	O	O
(	O	O
code	O	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
becomeActive	O	O
(	O	O
)	O	O
)	O	O
{	O	O
monitorActiveStatus	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
reJoinElectionAfterFailureToBecomeActive	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
return	O	O
;	O	O
}	O	O
if	O	O
(	O	O
isNodeExists	O	O
(	O	O
code	O	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
createRetryCount	O	O
==	O	O
0	O	O
)	O	O
{	O	O
becomeStandby	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
monitorActiveStatus	O	TRUE
(	O	O
)	O	O
;	O	O
return	O	O
;	O	O
}	O	O
String	O	TRUE
errorMessage	TRUE	TRUE
=	O	O
+	O	O
code	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
path	O	TRUE
;	O	O

Code	O	TRUE
code	O	TRUE
=	O	O
Code	O	TRUE
.	O	O
get	O	TRUE
(	O	O
rc	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
isSuccess	O	O
(	O	O
code	O	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
becomeActive	O	O
(	O	O
)	O	O
)	O	O
{	O	O
monitorActiveStatus	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
reJoinElectionAfterFailureToBecomeActive	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
return	O	O
;	O	O
}	O	O
if	O	O
(	O	O
isNodeExists	O	O
(	O	O
code	O	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
createRetryCount	TRUE	TRUE
==	O	O
0	O	O
)	O	O
{	O	O
becomeStandby	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
monitorActiveStatus	O	TRUE
(	O	O
)	O	O
;	O	O
return	O	O
;	O	O
}	O	O
String	O	TRUE
errorMessage	O	TRUE
=	O	O
+	O	O
code	O	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
path	O	TRUE
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
errorMessage	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
shouldRetry	O	O
(	O	O
code	O	TRUE
)	O	O
)	O	O
{	O	O

synchronized	O	O
void	O	O
processWatchEvent	O	O
(	O	O
ZooKeeper	O	O
zk	O	TRUE
,	O	O
WatchedEvent	O	O
event	TRUE	TRUE
)	O	O
{	O	O
Event	O	TRUE
.	O	O
EventType	O	TRUE
eventType	TRUE	TRUE
=	O	O
event	TRUE	TRUE
.	O	O
getType	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
isStaleClient	O	TRUE
(	O	O
zk	O	TRUE
)	O	O
)	O	O
return	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

reJoinElection	O	TRUE
(	O	O
0	O	O
)	O	O
;	O	O
break	O	O
;	O	O
case	O	O
SaslAuthenticated	O	O
:	O	O
LOG	O	O
.	O	O
info	O	O
(	O	O
)	O	O
;	O	O
break	O	O
;	O	O
default	O	O
:	O	O
fatalError	O	O
(	O	O
+	O	O
event	O	TRUE
.	O	O
getState	O	O
(	O	O
)	O	O
)	O	O
;	O	O
break	O	O
;	O	O
}	O	O
return	O	O
;	O	O
}	O	O
String	O	TRUE
path	TRUE	TRUE
=	O	O
event	O	TRUE
.	O	O
getPath	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
path	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
switch	O	O
(	O	O
eventType	TRUE	TRUE
)	O	O
{	O	O
case	O	O
NodeDeleted	O	O
:	O	O
if	O	O
(	O	O
state	O	O
==	O	O
State	O	O
.	O	O
ACTIVE	O	O
)	O	O
{	O	O
enterNeutralMode	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
joinElectionInternal	O	TRUE
(	O	O
)	O	O
;	O	O
break	O	O
;	O	O
case	O	O
NodeDataChanged	O	O
:	O	O
monitorActiveStatus	O	O
(	O	O
)	O	O
;	O	O

private	O	O
void	O	O
fatalError	O	O
(	O	O
String	O	O
errorMessage	TRUE	TRUE
)	O	O
{	O	O

boolean	O	O
tryFence	O	TRUE
=	O	O
true	O	O
;	O	O
if	O	O
(	O	O
tryGracefulFence	O	O
(	O	O
fromSvc	O	TRUE
)	O	O
)	O	O
{	O	O
tryFence	O	TRUE
=	O	O
forceFence	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
tryFence	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
!	O	O
fromSvc	O	TRUE
.	O	O
getFencer	O	O
(	O	O
)	O	O
.	O	O
fence	O	O
(	O	O
fromSvc	O	TRUE
,	O	O
toSvc	TRUE	TRUE
)	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
FailoverFailedException	O	TRUE
(	O	O
+	O	O
fromSvc	O	TRUE
+	O	O
)	O	O
;	O	O
}	O	O
}	O	O
boolean	O	O
failed	O	TRUE
=	O	O
false	O	O
;	O	O
Throwable	O	TRUE
cause	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
HAServiceProtocolHelper	O	TRUE
.	O	O
transitionToActive	O	TRUE
(	O	O
toSvc	TRUE	TRUE
.	O	O
getProxy	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
rpcTimeoutToNewActive	O	TRUE
)	O	O
,	O	O
createReqInfo	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
ServiceFailedException	O	O
sfe	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
toSvc	TRUE	TRUE
,	O	O
sfe	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
failed	O	TRUE
=	O	O
true	O	O
;	O	O
cause	O	TRUE
=	O	O
sfe	O	TRUE
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	TRUE	TRUE
)	O	O
{	O	O

Throwable	O	TRUE
cause	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
HAServiceProtocolHelper	O	TRUE
.	O	O
transitionToActive	O	TRUE
(	O	O
toSvc	O	TRUE
.	O	O
getProxy	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
rpcTimeoutToNewActive	O	TRUE
)	O	O
,	O	O
createReqInfo	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
ServiceFailedException	O	O
sfe	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
toSvc	O	TRUE
,	O	O
sfe	O	TRUE
.	O	O
getMessage	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
failed	O	TRUE
=	O	O
true	O	O
;	O	O
cause	O	TRUE
=	O	O
sfe	O	TRUE
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
toSvc	O	TRUE
,	O	O
ioe	O	TRUE
)	O	O
;	O	O
failed	O	TRUE
=	O	O
true	O	O
;	O	O
cause	O	TRUE
=	O	O
ioe	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
failed	O	TRUE
)	O	O
{	O	O
String	O	TRUE
msg	TRUE	TRUE
=	O	O
+	O	O
toSvc	O	TRUE
;	O	O
if	O	O
(	O	O
!	O	O
tryFence	O	O
)	O	O
{	O	O
try	O	O
{	O	O

private	O	O
synchronized	O	O
void	O	O
enterState	O	O
(	O	O
State	O	O
newState	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
newState	TRUE	TRUE
!=	O	O
state	O	O
)	O	O
{	O	O

LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
)	O	O
;	O	O
int	O	O
i	O	TRUE
=	O	O
0	O	O
;	O	O
for	O	O
(	O	O
FenceMethodWithArg	O	O
method	TRUE	TRUE
:	O	O
methods	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
(	O	O
++	O	O
i	O	TRUE
)	O	O
+	O	O
+	O	O
methods	O	TRUE
.	O	O
size	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
method	TRUE	TRUE
)	O	O
;	O	O
try	O	O
{	O	O
boolean	O	O
toSvcFencingFailed	O	TRUE
=	O	O
false	O	O
;	O	O
if	O	O
(	O	O
toSvc	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
toSvcFencingFailed	O	TRUE
=	O	O
!	O	O
method	TRUE	TRUE
.	O	O
method	TRUE	TRUE
.	O	O
tryFence	O	TRUE
(	O	O
toSvc	O	TRUE
,	O	O
method	TRUE	TRUE
.	O	O
arg	O	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
toSvcFencingFailed	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
if	O	O
(	O	O
method	TRUE	TRUE
.	O	O
method	TRUE	TRUE
.	O	O
tryFence	O	TRUE
(	O	O
fromSvc	O	O
,	O	O
method	TRUE	TRUE
.	O	O
arg	O	TRUE
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
method	TRUE	TRUE
+	O	O
)	O	O
;	O	O
return	O	O
true	O	O
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
BadFencingConfigurationException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
(	O	O
++	O	O
i	O	TRUE
)	O	O
+	O	O
+	O	O
methods	O	TRUE
.	O	O
size	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
method	TRUE	TRUE
)	O	O
;	O	O
try	O	O
{	O	O
boolean	O	O
toSvcFencingFailed	O	TRUE
=	O	O
false	O	O
;	O	O
if	O	O
(	O	O
toSvc	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
toSvcFencingFailed	O	TRUE
=	O	O
!	O	O
method	TRUE	TRUE
.	O	O
method	TRUE	TRUE
.	O	O
tryFence	O	TRUE
(	O	O
toSvc	O	TRUE
,	O	O
method	TRUE	TRUE
.	O	O
arg	O	TRUE
)	O	O
;	O	O
}	O	O
if	O	O
(	O	O
toSvcFencingFailed	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
if	O	O
(	O	O
method	TRUE	TRUE
.	O	O
method	TRUE	TRUE
.	O	O
tryFence	O	TRUE
(	O	O
fromSvc	O	O
,	O	O
method	TRUE	TRUE
.	O	O
arg	O	TRUE
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
method	TRUE	TRUE
+	O	O
)	O	O
;	O	O
return	O	O
true	O	O
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
BadFencingConfigurationException	O	O
e	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
method	TRUE	TRUE
+	O	O
,	O	O
e	O	TRUE
)	O	O
;	O	O
continue	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Throwable	O	O
t	TRUE	TRUE
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
checkArgs	O	O
(	O	O
String	O	O
argStr	TRUE	TRUE
)	O	O
throws	O	O
BadFencingConfigurationException	O	O
{	O	O

private	O	O
String	O	O
buildPSScript	O	O
(	O	O
final	O	O
String	O	O
processName	TRUE	TRUE
,	O	O
final	O	O
String	O	O
host	TRUE	TRUE
)	O	O
{	O	O

private	O	O
String	O	TRUE
buildPSScript	O	O
(	O	O
final	O	O
String	O	TRUE
processName	O	TRUE
,	O	O
final	O	O
String	O	TRUE
host	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
processName	O	TRUE
+	O	O
+	O	O
host	O	TRUE
)	O	O
;	O	O
String	O	TRUE
ps1script	O	TRUE
=	O	O
null	O	O
;	O	O
BufferedWriter	O	TRUE
writer	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
File	O	TRUE
file	O	TRUE
=	O	O
File	O	TRUE
.	O	O
createTempFile	O	TRUE
(	O	O
,	O	O
)	O	O
;	O	O
file	O	TRUE
.	O	O
deleteOnExit	O	TRUE
(	O	O
)	O	O
;	O	O
FileOutputStream	O	TRUE
fos	O	TRUE
=	O	O
new	O	O
FileOutputStream	O	TRUE
(	O	O
file	O	TRUE
,	O	O
false	O	O
)	O	O
;	O	O
OutputStreamWriter	O	TRUE
osw	O	TRUE
=	O	O
new	O	O
OutputStreamWriter	O	TRUE
(	O	O
fos	O	TRUE
,	O	O
StandardCharsets	O	TRUE
.	O	O
UTF_8	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
=	O	O
new	O	O
BufferedWriter	O	TRUE
(	O	O
osw	O	TRUE
)	O	O
;	O	O
String	O	TRUE
filter	O	TRUE
=	O	O
StringUtils	O	TRUE
.	O	O
join	O	TRUE
(	O	O
,	O	O
new	O	O
String	O	TRUE
[	O	O
]	O	O
{	O	O
,	O	O
+	O	O
processName	O	TRUE
+	O	O
}	O	O
)	O	O
;	O	O
String	O	TRUE
cmd	TRUE	TRUE
=	O	O
;	O	O
cmd	TRUE	TRUE
+=	O	O
+	O	O
filter	O	TRUE
+	O	O
;	O	O
cmd	TRUE	TRUE
+=	O	O
+	O	O
host	O	TRUE
;	O	O
cmd	TRUE	TRUE
+=	O	O
;	O	O

File	O	TRUE
file	O	TRUE
=	O	O
File	O	TRUE
.	O	O
createTempFile	O	TRUE
(	O	O
,	O	O
)	O	O
;	O	O
file	O	TRUE
.	O	O
deleteOnExit	O	TRUE
(	O	O
)	O	O
;	O	O
FileOutputStream	O	TRUE
fos	O	TRUE
=	O	O
new	O	O
FileOutputStream	O	TRUE
(	O	O
file	O	TRUE
,	O	O
false	O	O
)	O	O
;	O	O
OutputStreamWriter	O	TRUE
osw	O	TRUE
=	O	O
new	O	O
OutputStreamWriter	O	TRUE
(	O	O
fos	O	TRUE
,	O	O
StandardCharsets	O	TRUE
.	O	O
UTF_8	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
=	O	O
new	O	O
BufferedWriter	O	TRUE
(	O	O
osw	O	TRUE
)	O	O
;	O	O
String	O	TRUE
filter	O	TRUE
=	O	O
StringUtils	O	TRUE
.	O	O
join	O	TRUE
(	O	O
,	O	O
new	O	O
String	O	TRUE
[	O	O
]	O	O
{	O	O
,	O	O
+	O	O
processName	O	TRUE
+	O	O
}	O	O
)	O	O
;	O	O
String	O	TRUE
cmd	O	TRUE
=	O	O
;	O	O
cmd	O	TRUE
+=	O	O
+	O	O
filter	O	TRUE
+	O	O
;	O	O
cmd	O	TRUE
+=	O	O
+	O	O
host	O	TRUE
;	O	O
cmd	O	TRUE
+=	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
cmd	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
.	O	O
write	O	TRUE
(	O	O
cmd	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
.	O	O
flush	O	TRUE
(	O	O
)	O	O
;	O	O
ps1script	O	TRUE
=	O	O
file	O	TRUE
.	O	O
getAbsolutePath	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	TRUE	TRUE
)	O	O
{	O	O

String	O	TRUE
cmd	O	TRUE
=	O	O
;	O	O
cmd	O	TRUE
+=	O	O
+	O	O
filter	O	TRUE
+	O	O
;	O	O
cmd	O	TRUE
+=	O	O
+	O	O
host	O	TRUE
;	O	O
cmd	O	TRUE
+=	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
cmd	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
.	O	O
write	O	TRUE
(	O	O
cmd	O	TRUE
)	O	O
;	O	O
writer	O	TRUE
.	O	O
flush	O	TRUE
(	O	O
)	O	O
;	O	O
ps1script	O	TRUE
=	O	O
file	O	TRUE
.	O	O
getAbsolutePath	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
ioe	TRUE	TRUE
)	O	O
;	O	O
}	O	O
finally	O	O
{	O	O
if	O	O
(	O	O
writer	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
try	O	O
{	O	O
writer	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
ioe	TRUE	TRUE
)	O	O
{	O	O

String	O	TRUE
cmd	TRUE	TRUE
=	O	O
parseArgs	O	TRUE
(	O	O
target	O	TRUE
.	O	O
getTransitionTargetHAStatus	O	TRUE
(	O	O
)	O	O
,	O	O
args	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
Shell	O	O
.	O	O
WINDOWS	O	O
)	O	O
{	O	O
builder	O	TRUE
=	O	O
new	O	O
ProcessBuilder	O	TRUE
(	O	O
,	O	O
,	O	O
,	O	O
cmd	TRUE	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
builder	O	TRUE
=	O	O
new	O	O
ProcessBuilder	O	TRUE
(	O	O
,	O	O
,	O	O
cmd	TRUE	TRUE
)	O	O
;	O	O
}	O	O
setConfAsEnvVars	O	TRUE
(	O	O
builder	O	TRUE
.	O	O
environment	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
addTargetInfoAsEnvVars	O	TRUE
(	O	O
target	O	TRUE
,	O	O
builder	O	TRUE
.	O	O
environment	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
Process	O	TRUE
p	O	TRUE
;	O	O
try	O	O
{	O	O
p	O	TRUE
=	O	O
builder	O	TRUE
.	O	O
start	O	TRUE
(	O	O
)	O	O
;	O	O
p	O	TRUE
.	O	O
getOutputStream	O	TRUE
(	O	O
)	O	O
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
+	O	O
cmd	TRUE	TRUE
,	O	O
e	O	TRUE
)	O	O
;	O	O
return	O	O
false	O	O
;	O	O
}	O	O
String	O	TRUE
pid	O	TRUE
=	O	O
tryGetPid	O	TRUE
(	O	O
p	O	TRUE
)	O	O
;	O	O

private	O	O
boolean	O	O
doFence	O	O
(	O	O
Session	O	O
session	O	O
,	O	O
InetSocketAddress	O	O
serviceAddr	O	TRUE
)	O	O
throws	O	O
JSchException	O	O
{	O	O
int	O	O
port	TRUE	TRUE
=	O	O
serviceAddr	O	TRUE
.	O	O
getPort	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O

private	O	O
boolean	O	O
doFence	O	O
(	O	O
Session	O	O
session	O	TRUE
,	O	O
InetSocketAddress	O	O
serviceAddr	O	TRUE
)	O	O
throws	O	O
JSchException	O	O
{	O	O
int	O	O
port	TRUE	TRUE
=	O	O
serviceAddr	O	TRUE
.	O	O
getPort	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
port	TRUE	TRUE
)	O	O
;	O	O
int	O	O
rc	O	TRUE
=	O	O
execCommand	O	TRUE
(	O	O
session	O	TRUE
,	O	O
+	O	O
port	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
rc	O	TRUE
==	O	O
0	O	O
)	O	O
{	O	O

private	O	O
int	O	O
execCommand	O	O
(	O	O
Session	O	O
session	O	O
,	O	O
String	O	O
cmd	TRUE	TRUE
)	O	O
throws	O	O
JSchException	O	O
,	O	O
InterruptedException	O	O
,	O	O
IOException	O	O
{	O	O

protected	O	O
void	O	O
pump	O	O
(	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
InputStreamReader	O	TRUE
inputStreamReader	O	TRUE
=	O	O
new	O	O
InputStreamReader	O	TRUE
(	O	O
stream	O	TRUE
,	O	O
StandardCharsets	O	TRUE
.	O	O
UTF_8	O	TRUE
)	O	O
;	O	O
BufferedReader	O	TRUE
br	O	TRUE
=	O	O
new	O	O
BufferedReader	O	TRUE
(	O	O
inputStreamReader	O	TRUE
)	O	O
;	O	O
String	O	TRUE
line	TRUE	TRUE
=	O	O
null	O	O
;	O	O
while	O	O
(	O	O
(	O	O
line	TRUE	TRUE
=	O	O
br	O	TRUE
.	O	O
readLine	O	O
(	O	O
)	O	O
)	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
type	O	O
==	O	O
StreamType	O	O
.	O	O
STDOUT	O	O
)	O	O
{	O	O

public	O	O
int	O	O
run	O	O
(	O	O
final	O	O
String	O	O
[	O	O
]	O	O
args	O	O
)	O	O
throws	O	O
Exception	O	O
{	O	O
if	O	O
(	O	O
!	O	O
localTarget	TRUE	TRUE
.	O	O
isAutoFailoverEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

force	O	TRUE
=	O	O
true	O	O
;	O	O
}	O	O
else	O	O
if	O	O
(	O	O
.	O	O
equals	O	O
(	O	O
args	O	TRUE
[	O	O
i	O	TRUE
]	O	O
)	O	O
)	O	O
{	O	O
interactive	O	TRUE
=	O	O
false	O	O
;	O	O
}	O	O
else	O	O
{	O	O
badArg	O	TRUE
(	O	O
args	O	TRUE
[	O	O
i	O	TRUE
]	O	O
)	O	O
;	O	O
}	O	O
}	O	O
return	O	O
formatZK	O	TRUE
(	O	O
force	O	TRUE
,	O	O
interactive	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
badArg	O	TRUE
(	O	O
args	O	TRUE
[	O	O
0	O	O
]	O	O
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
throw	O	O
e	TRUE	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
!	O	O
elector	O	O
.	O	O
parentZNodeExists	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
+	O	O
)	O	O
;	O	O
return	O	O
ERR_CODE_NO_PARENT_ZNODE	O	TRUE
;	O	O
}	O	O
try	O	O
{	O	O

}	O	O
return	O	O
formatZK	O	TRUE
(	O	O
force	O	TRUE
,	O	O
interactive	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
badArg	O	TRUE
(	O	O
args	O	TRUE
[	O	O
0	O	O
]	O	O
)	O	O
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
throw	O	O
e	TRUE	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
!	O	O
elector	O	O
.	O	O
parentZNodeExists	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
+	O	O
)	O	O
;	O	O
return	O	O
ERR_CODE_NO_PARENT_ZNODE	O	TRUE
;	O	O
}	O	O
try	O	O
{	O	O
localTarget	O	TRUE
.	O	O
checkFencingConfigured	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
BadFencingConfigurationException	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
localTarget	O	TRUE
+	O	O
+	O	O
+	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
return	O	O
ERR_CODE_NO_FENCER	O	TRUE
;	O	O
}	O	O
try	O	O
{	O	O

protected	O	O
void	O	O
initRPC	O	O
(	O	O
)	O	O
throws	O	O
IOException	O	O
{	O	O
InetSocketAddress	O	TRUE
bindAddr	TRUE	TRUE
=	O	O
getRpcAddressToBindTo	O	TRUE
(	O	O
)	O	O
;	O	O

private	O	O
synchronized	O	O
void	O	O
fatalError	O	O
(	O	O
String	O	O
err	TRUE	TRUE
)	O	O
{	O	O

private	O	O
synchronized	O	O
void	O	O
becomeActive	O	O
(	O	O
)	O	O
throws	O	O
ServiceFailedException	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
localTarget	O	TRUE
+	O	O
)	O	O
;	O	O
try	O	O
{	O	O
HAServiceProtocolHelper	O	TRUE
.	O	O
transitionToActive	O	TRUE
(	O	O
localTarget	O	TRUE
.	O	O
getProxy	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
FailoverController	O	TRUE
.	O	O
getRpcTimeoutToNewActive	O	TRUE
(	O	O
conf	O	TRUE
)	O	O
)	O	O
,	O	O
createReqInfo	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
String	O	TRUE
msg	TRUE	TRUE
=	O	O
+	O	O
localTarget	O	TRUE
+	O	O
;	O	O

private	O	O
synchronized	O	O
void	O	O
becomeStandby	O	O
(	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
localTarget	TRUE	TRUE
+	O	O
)	O	O
;	O	O
try	O	O
{	O	O
int	O	O
timeout	O	TRUE
=	O	O
FailoverController	O	TRUE
.	O	O
getGracefulFenceTimeout	O	TRUE
(	O	O
conf	O	TRUE
)	O	O
;	O	O
localTarget	TRUE	TRUE
.	O	O
getProxy	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
timeout	O	TRUE
)	O	O
.	O	O
transitionToStandby	O	TRUE
(	O	O
createReqInfo	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

private	O	O
void	O	O
doFence	O	O
(	O	O
HAServiceTarget	O	O
target	TRUE	TRUE
)	O	O
{	O	O

private	O	O
void	O	O
doFence	O	O
(	O	O
HAServiceTarget	O	O
target	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
target	TRUE	TRUE
)	O	O
;	O	O
boolean	O	O
gracefulWorked	O	TRUE
=	O	O
new	O	O
FailoverController	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
RequestSource	O	TRUE
.	O	O
REQUEST_BY_ZKFC	O	TRUE
)	O	O
.	O	O
tryGracefulFence	O	TRUE
(	O	O
target	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
gracefulWorked	O	TRUE
)	O	O
{	O	O

private	O	O
ZKFCProtocol	O	O
cedeRemoteActive	O	O
(	O	O
HAServiceTarget	O	O
remote	TRUE	TRUE
,	O	O
int	O	O
timeout	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
{	O	O

protected	O	O
synchronized	O	O
void	O	O
setLastHealthState	O	O
(	O	O
HealthMonitor	O	O
.	O	O
State	O	O
newState	TRUE	TRUE
)	O	O
{	O	O

;	O	O
try	O	O
{	O	O
isLog4JLogger	O	TRUE
=	O	O
logger	O	TRUE
instanceof	O	O
Log4JLogger	O	TRUE
;	O	O
}	O	O
catch	O	O
(	O	O
NoClassDefFoundError	O	O
err	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
err	O	TRUE
)	O	O
;	O	O
isLog4JLogger	O	TRUE
=	O	O
false	O	O
;	O	O
}	O	O
if	O	O
(	O	O
isLog4JLogger	O	TRUE
)	O	O
{	O	O
Log4JLogger	O	TRUE
httpLog4JLog	O	TRUE
=	O	O
(	O	O
Log4JLogger	O	TRUE
)	O	O
logger	O	TRUE
;	O	O
org	O	TRUE
.	O	O
apache	O	TRUE
.	O	O
log4j	O	TRUE
.	O	O
Logger	O	TRUE
httpLogger	O	TRUE
=	O	O
httpLog4JLog	O	TRUE
.	O	O
getLogger	O	TRUE
(	O	O
)	O	O
;	O	O
Appender	O	TRUE
appender	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
appender	O	TRUE
=	O	O
httpLogger	O	TRUE
.	O	O
getAppender	O	TRUE
(	O	O
appenderName	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
LogConfigurationException	O	O
e	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
,	O	O
loggerName	TRUE	TRUE
)	O	O
;	O	O
throw	O	O
e	O	TRUE
;	O	O

public	O	O
void	O	O
addJerseyResourcePackage	O	O
(	O	O
final	O	O
String	O	O
packageName	TRUE	TRUE
,	O	O
final	O	O
String	O	O
pathSpec	TRUE	TRUE
,	O	O
Map	O	O
<	O	O
String	O	O
,	O	O
String	O	O
>	O	O
params	O	O
)	O	O
{	O	O

public	O	O
void	O	O
addInternalServlet	O	O
(	O	O
String	O	O
name	O	TRUE
,	O	O
String	O	O
pathSpec	TRUE	TRUE
,	O	O
Class	O	O
<	O	O
?	O	O
extends	O	O
HttpServlet	O	O
>	O	O
clazz	O	TRUE
,	O	O
Map	O	O
<	O	O
String	O	O
,	O	O
String	O	O
>	O	O
params	O	TRUE
)	O	O
{	O	O
final	O	O
ServletHolder	O	TRUE
sh	O	TRUE
=	O	O
new	O	O
ServletHolder	O	TRUE
(	O	O
clazz	O	TRUE
)	O	O
;	O	O
sh	O	TRUE
.	O	O
setName	O	TRUE
(	O	O
name	O	TRUE
)	O	O
;	O	O
sh	O	TRUE
.	O	O
setInitParameters	O	TRUE
(	O	O
params	O	TRUE
)	O	O
;	O	O
final	O	O
ServletMapping	O	TRUE
[	O	O
]	O	O
servletMappings	O	TRUE
=	O	O
webAppContext	O	TRUE
.	O	O
getServletHandler	O	TRUE
(	O	O
)	O	O
.	O	O
getServletMappings	O	TRUE
(	O	O
)	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	O	O
=	O	O
0	O	O
;	O	O
i	O	O
<	O	O
servletMappings	O	TRUE
.	O	O
length	O	O
;	O	O
i	O	O
++	O	O
)	O	O
{	O	O
if	O	O
(	O	O
servletMappings	O	TRUE
[	O	O
i	O	O
]	O	O
.	O	O
containsPathSpec	O	O
(	O	O
pathSpec	TRUE	TRUE
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
addFilter	O	O
(	O	O
String	O	TRUE
name	TRUE	TRUE
,	O	O
String	O	TRUE
classname	TRUE	TRUE
,	O	O
Map	O	O
<	O	O
String	O	TRUE
,	O	O
String	O	TRUE
>	O	O
parameters	O	TRUE
)	O	O
{	O	O
FilterHolder	O	TRUE
filterHolder	O	TRUE
=	O	O
getFilterHolder	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
classname	TRUE	TRUE
,	O	O
parameters	O	TRUE
)	O	O
;	O	O
final	O	O
String	O	TRUE
[	O	O
]	O	O
userFacingUrls	O	TRUE
=	O	O
{	O	O
,	O	O
}	O	O
;	O	O
FilterMapping	O	TRUE
fmap	O	TRUE
=	O	O
getFilterMapping	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
userFacingUrls	O	TRUE
)	O	O
;	O	O
defineFilter	O	TRUE
(	O	O
webAppContext	TRUE	TRUE
,	O	O
filterHolder	O	TRUE
,	O	O
fmap	O	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
addFilter	O	O
(	O	O
String	O	TRUE
name	TRUE	TRUE
,	O	O
String	O	TRUE
classname	TRUE	TRUE
,	O	O
Map	O	O
<	O	O
String	O	TRUE
,	O	O
String	O	TRUE
>	O	O
parameters	O	TRUE
)	O	O
{	O	O
FilterHolder	O	TRUE
filterHolder	O	TRUE
=	O	O
getFilterHolder	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
classname	TRUE	TRUE
,	O	O
parameters	O	TRUE
)	O	O
;	O	O
final	O	O
String	O	TRUE
[	O	O
]	O	O
userFacingUrls	O	TRUE
=	O	O
{	O	O
,	O	O
}	O	O
;	O	O
FilterMapping	O	TRUE
fmap	O	TRUE
=	O	O
getFilterMapping	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
userFacingUrls	O	TRUE
)	O	O
;	O	O
defineFilter	O	TRUE
(	O	O
webAppContext	O	TRUE
,	O	O
filterHolder	O	TRUE
,	O	O
fmap	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
+	O	O
name	TRUE	TRUE
+	O	O
+	O	O
classname	TRUE	TRUE
+	O	O
+	O	O
webAppContext	O	TRUE
.	O	O
getDisplayName	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
final	O	O
String	O	TRUE
[	O	O
]	O	O
ALL_URLS	O	TRUE
=	O	O
{	O	O
}	O	O
;	O	O
fmap	O	TRUE
=	O	O
getFilterMapping	O	TRUE
(	O	O
name	TRUE	TRUE
,	O	O
ALL_URLS	O	TRUE
)	O	O
;	O	O
for	O	O
(	O	O
Map	O	O
.	O	O
Entry	O	O
<	O	O
ServletContextHandler	O	TRUE
,	O	O
Boolean	O	O
>	O	O
e	O	TRUE
:	O	O
defaultContexts	O	O
.	O	O
entrySet	O	O
(	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
e	O	TRUE
.	O	O
getValue	O	O
(	O	O
)	O	O
)	O	O
{	O	O
ServletContextHandler	O	TRUE
ctx	TRUE	TRUE
=	O	O
e	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
;	O	O
defineFilter	O	TRUE
(	O	O
ctx	TRUE	TRUE
,	O	O
filterHolder	O	TRUE
,	O	O
fmap	O	TRUE
)	O	O
;	O	O

private	O	O
static	O	O
void	O	O
bindListener	O	O
(	O	O
ServerConnector	O	O
listener	TRUE	TRUE
)	O	O
throws	O	O
Exception	O	O
{	O	O
listener	TRUE	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
listener	TRUE	TRUE
.	O	O
open	O	TRUE
(	O	O
)	O	O
;	O	O

try	O	O
{	O	O
c	O	TRUE
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
webAppContext	TRUE	TRUE
.	O	O
getDisplayName	O	TRUE
(	O	O
)	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
exception	O	TRUE
=	O	O
addMultiException	O	TRUE
(	O	O
exception	O	TRUE
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
try	O	O
{	O	O
secretProvider	O	TRUE
.	O	O
destroy	O	TRUE
(	O	O
)	O	O
;	O	O
webAppContext	TRUE	TRUE
.	O	O
clearAttributes	O	TRUE
(	O	O
)	O	O
;	O	O
webAppContext	TRUE	TRUE
.	O	O
stop	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
+	O	O
webAppContext	TRUE	TRUE
.	O	O
getDisplayName	O	TRUE
(	O	O
)	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
exception	O	TRUE
=	O	O
addMultiException	O	TRUE
(	O	O
exception	O	TRUE
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
}	O	O
try	O	O
{	O	O
webServer	O	TRUE
.	O	O
stop	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
{	O	O

public	O	O
static	O	O
Compressor	O	TRUE
getCompressor	O	O
(	O	O
CompressionCodec	O	O
codec	TRUE	TRUE
,	O	O
Configuration	O	O
conf	O	O
)	O	O
{	O	O
Compressor	O	TRUE
compressor	O	TRUE
=	O	O
borrow	O	TRUE
(	O	O
compressorPool	O	TRUE
,	O	O
codec	TRUE	TRUE
.	O	O
getCompressorType	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
compressor	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
compressor	O	TRUE
=	O	O
codec	TRUE	TRUE
.	O	O
createCompressor	O	TRUE
(	O	O
)	O	O
;	O	O

public	O	O
static	O	O
Decompressor	O	TRUE
getDecompressor	O	O
(	O	O
CompressionCodec	O	O
codec	TRUE	TRUE
)	O	O
{	O	O
Decompressor	O	TRUE
decompressor	O	TRUE
=	O	O
borrow	O	TRUE
(	O	O
decompressorPool	O	TRUE
,	O	O
codec	TRUE	TRUE
.	O	O
getDecompressorType	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
decompressor	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
decompressor	O	TRUE
=	O	O
codec	TRUE	TRUE
.	O	O
createDecompressor	O	TRUE
(	O	O
)	O	O
;	O	O

@	O	O
VisibleForTesting	O	O
void	O	O
updateCoders	O	O
(	O	O
Iterable	O	O
<	O	O
RawErasureCoderFactory	O	TRUE
>	O	O
coderFactories	O	O
)	O	O
{	O	O
for	O	O
(	O	O
RawErasureCoderFactory	O	TRUE
coderFactory	TRUE	TRUE
:	O	O
coderFactories	O	O
)	O	O
{	O	O
String	O	TRUE
codecName	O	TRUE
=	O	O
coderFactory	TRUE	TRUE
.	O	O
getCodecName	O	TRUE
(	O	O
)	O	O
;	O	O
List	O	TRUE
<	O	O
RawErasureCoderFactory	O	TRUE
>	O	O
coders	O	TRUE
=	O	O
coderMap	O	TRUE
.	O	O
get	O	TRUE
(	O	O
codecName	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
coders	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
coders	O	TRUE
=	O	O
new	O	O
ArrayList	O	TRUE
<	O	O
>	O	O
(	O	O
)	O	O
;	O	O
coders	O	TRUE
.	O	O
add	O	TRUE
(	O	O
coderFactory	TRUE	TRUE
)	O	O
;	O	O
coderMap	O	TRUE
.	O	O
put	O	TRUE
(	O	O
codecName	O	TRUE
,	O	O
coders	O	TRUE
)	O	O
;	O	O

@	O	O
Override	O	O
public	O	O
synchronized	O	O
boolean	O	O
isSupported	O	O
(	O	O
)	O	O
{	O	O
if	O	O
(	O	O
!	O	O
checked	O	TRUE
||	O	O
reinitCodecInTests	O	TRUE
)	O	O
{	O	O
checked	O	TRUE
=	O	O
true	O	O
;	O	O
reinitCodecInTests	O	TRUE
=	O	O
conf	O	TRUE
.	O	O
getBoolean	O	TRUE
(	O	O
,	O	O
false	O	O
)	O	O
;	O	O
clazz	TRUE	TRUE
=	O	O
getLzoCodecClass	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O

public	O	O
void	O	O
returnCompressor	O	O
(	O	O
Compressor	O	O
compressor	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
compressor	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

public	O	O
void	O	O
returnDecompressor	O	O
(	O	O
Decompressor	O	O
decompressor	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
decompressor	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
protected	O	O
Object	O	TRUE
invokeMethod	O	TRUE
(	O	O
Method	O	O
method	O	TRUE
,	O	O
Object	O	TRUE
[	O	O
]	O	O
args	O	TRUE
)	O	O
throws	O	O
Throwable	O	O
{	O	O
Object	O	TRUE
result	O	TRUE
=	O	O
super	O	O
.	O	O
invokeMethod	O	TRUE
(	O	O
method	O	TRUE
,	O	O
args	O	TRUE
)	O	O
;	O	O
int	O	O
retryCount	TRUE	TRUE
=	O	O
RetryCount	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
retryCount	TRUE	TRUE
<	O	O
this	O	O
.	O	O
numToDrop	O	O
)	O	O
{	O	O
RetryCount	O	TRUE
.	O	O
set	O	TRUE
(	O	O
++	O	O
retryCount	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
RetryInfo	O	TRUE
handleException	O	O
(	O	O
final	O	O
Method	O	O
method	O	TRUE
,	O	O
final	O	O
int	O	O
callId	TRUE	TRUE
,	O	O
final	O	O
RetryPolicy	O	O
policy	O	TRUE
,	O	O
final	O	O
Counters	O	O
counters	O	TRUE
,	O	O
final	O	O
long	O	O
expectFailoverCount	O	TRUE
,	O	O
final	O	O
Exception	O	O
e	TRUE	TRUE
)	O	O
throws	O	O
Exception	O	O
{	O	O
final	O	O
RetryInfo	O	TRUE
retryInfo	O	TRUE
=	O	O
RetryInfo	O	TRUE
.	O	O
newRetryInfo	O	TRUE
(	O	O
policy	O	TRUE
,	O	O
e	TRUE	TRUE
,	O	O
counters	O	TRUE
,	O	O
proxyDescriptor	O	TRUE
.	O	O
idempotentOrAtMostOnce	O	TRUE
(	O	O
method	O	TRUE
)	O	O
,	O	O
expectFailoverCount	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
retryInfo	O	TRUE
.	O	O
isFail	O	O
(	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
retryInfo	O	TRUE
.	O	O
action	O	O
.	O	O
reason	O	O
!=	O	O
null	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
void	O	O
log	O	O
(	O	O
final	O	O
Method	O	O
method	O	TRUE
,	O	O
final	O	O
boolean	O	O
isFailover	O	TRUE
,	O	O
final	O	O
int	O	O
failovers	O	TRUE
,	O	O
final	O	O
long	O	O
delay	O	TRUE
,	O	O
final	O	O
Exception	O	O
ex	TRUE	TRUE
)	O	O
{	O	O
boolean	O	O
info	O	TRUE
=	O	O
true	O	O
;	O	O
if	O	O
(	O	O
!	O	O
failedAtLeastOnce	O	TRUE
.	O	O
contains	O	O
(	O	O
proxyDescriptor	O	TRUE
.	O	O
getProxyInfo	O	TRUE
(	O	O
)	O	O
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
{	O	O
failedAtLeastOnce	O	TRUE
.	O	O
add	O	TRUE
(	O	O
proxyDescriptor	O	TRUE
.	O	O
getProxyInfo	O	TRUE
(	O	O
)	O	O
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
info	O	TRUE
=	O	O
hasSuccessfulCall	O	TRUE
||	O	O
asyncCallHandler	O	TRUE
.	O	O
hasSuccessfulCall	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
!	O	O
info	O	TRUE
&&	O	O
!	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
return	O	O
;	O	O
}	O	O
}	O	O
final	O	O
StringBuilder	O	TRUE
b	TRUE	TRUE
=	O	O
new	O	O
StringBuilder	O	TRUE
(	O	O
)	O	O
.	O	O
append	O	TRUE
(	O	O
ex	TRUE	TRUE
+	O	O
)	O	O
.	O	O
append	O	TRUE
(	O	O
proxyDescriptor	O	TRUE
.	O	O
getProxyInfo	O	TRUE
(	O	O
)	O	O
.	O	O
getString	O	TRUE
(	O	O
method	O	TRUE
.	O	O
getName	O	TRUE
(	O	O
)	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
failovers	O	TRUE
>	O	O
0	O	O
)	O	O
{	O	O
b	TRUE	TRUE
.	O	O
append	O	TRUE
(	O	O
)	O	O
.	O	O
append	O	TRUE
(	O	O
failovers	O	TRUE
)	O	O
.	O	O
append	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
b	TRUE	TRUE
.	O	O
append	O	TRUE
(	O	O
isFailover	O	TRUE
?	O	O
:	O	O
)	O	O
;	O	O
b	TRUE	TRUE
.	O	O
append	O	TRUE
(	O	O
delay	O	TRUE
>	O	O
0	O	O
?	O	O
+	O	O
delay	O	TRUE
+	O	O
:	O	O
)	O	O
;	O	O
if	O	O
(	O	O
info	O	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
info	O	TRUE
(	O	O
b	TRUE	TRUE
.	O	O
toString	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O

public	O	O
static	O	O
RetryPolicy	O	TRUE
getDefaultRetryPolicy	O	O
(	O	O
Configuration	O	O
conf	O	TRUE
,	O	O
String	O	O
retryPolicyEnabledKey	O	TRUE
,	O	O
boolean	O	O
defaultRetryPolicyEnabled	O	TRUE
,	O	O
String	O	O
retryPolicySpecKey	O	TRUE
,	O	O
String	O	O
defaultRetryPolicySpec	O	TRUE
,	O	O
final	O	O
String	O	O
remoteExceptionToRetry	O	O
)	O	O
{	O	O
final	O	O
RetryPolicy	O	TRUE
multipleLinearRandomRetry	TRUE	TRUE
=	O	O
getMultipleLinearRandomRetry	O	TRUE
(	O	O
conf	O	TRUE
,	O	O
retryPolicyEnabledKey	O	TRUE
,	O	O
defaultRetryPolicyEnabled	O	TRUE
,	O	O
retryPolicySpecKey	O	TRUE
,	O	O
defaultRetryPolicySpec	O	TRUE
)	O	O
;	O	O

private	O	O
void	O	O
decayCurrentCosts	O	O
(	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
)	O	O
;	O	O
try	O	O
{	O	O
long	O	O
totalDecayedCost	O	TRUE
=	O	O
0	O	O
;	O	O
long	O	O
totalRawCost	O	TRUE
=	O	O
0	O	O
;	O	O
Iterator	O	TRUE
<	O	O
Map	O	TRUE
.	O	O
Entry	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
List	O	TRUE
<	O	O
AtomicLong	O	TRUE
>>>	O	O
it	O	TRUE
=	O	O
callCosts	O	TRUE
.	O	O
entrySet	O	TRUE
(	O	O
)	O	O
.	O	O
iterator	O	TRUE
(	O	O
)	O	O
;	O	O
while	O	O
(	O	O
it	O	TRUE
.	O	O
hasNext	O	O
(	O	O
)	O	O
)	O	O
{	O	O
Map	O	TRUE
.	O	O
Entry	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
List	O	TRUE
<	O	O
AtomicLong	O	TRUE
>>	O	O
entry	TRUE	TRUE
=	O	O
it	O	TRUE
.	O	O
next	O	TRUE
(	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
decayedCost	O	TRUE
=	O	O
entry	TRUE	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
0	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
rawCost	TRUE	TRUE
=	O	O
entry	TRUE	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
1	O	O
)	O	O
;	O	O
totalRawCost	O	TRUE
+=	O	O
rawCost	TRUE	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
currentValue	O	TRUE
=	O	O
decayedCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
nextValue	TRUE	TRUE
=	O	O
(	O	O
long	O	O
)	O	O
(	O	O
currentValue	O	TRUE
*	O	O
decayFactor	O	TRUE
)	O	O
;	O	O
totalDecayedCost	O	TRUE
+=	O	O
nextValue	TRUE	TRUE
;	O	O
decayedCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
nextValue	TRUE	TRUE
)	O	O
;	O	O

try	O	O
{	O	O
long	O	O
totalDecayedCost	O	TRUE
=	O	O
0	O	O
;	O	O
long	O	O
totalRawCost	O	TRUE
=	O	O
0	O	O
;	O	O
Iterator	O	TRUE
<	O	O
Map	O	TRUE
.	O	O
Entry	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
List	O	TRUE
<	O	O
AtomicLong	O	TRUE
>>>	O	O
it	O	TRUE
=	O	O
callCosts	O	TRUE
.	O	O
entrySet	O	TRUE
(	O	O
)	O	O
.	O	O
iterator	O	TRUE
(	O	O
)	O	O
;	O	O
while	O	O
(	O	O
it	O	TRUE
.	O	O
hasNext	O	O
(	O	O
)	O	O
)	O	O
{	O	O
Map	O	TRUE
.	O	O
Entry	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
List	O	TRUE
<	O	O
AtomicLong	O	TRUE
>>	O	O
entry	TRUE	TRUE
=	O	O
it	O	TRUE
.	O	O
next	O	TRUE
(	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
decayedCost	O	TRUE
=	O	O
entry	TRUE	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
0	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
rawCost	O	TRUE
=	O	O
entry	TRUE	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
1	O	O
)	O	O
;	O	O
totalRawCost	O	TRUE
+=	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
currentValue	O	TRUE
=	O	O
decayedCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
nextValue	O	TRUE
=	O	O
(	O	O
long	O	O
)	O	O
(	O	O
currentValue	O	TRUE
*	O	O
decayFactor	O	TRUE
)	O	O
;	O	O
totalDecayedCost	O	TRUE
+=	O	O
nextValue	O	TRUE
;	O	O
decayedCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
nextValue	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
entry	TRUE	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
,	O	O
nextValue	O	TRUE
,	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
nextValue	O	TRUE
==	O	O
0	O	O
)	O	O
{	O	O

while	O	O
(	O	O
it	O	TRUE
.	O	O
hasNext	O	O
(	O	O
)	O	O
)	O	O
{	O	O
Map	O	TRUE
.	O	O
Entry	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
List	O	TRUE
<	O	O
AtomicLong	O	TRUE
>>	O	O
entry	O	TRUE
=	O	O
it	O	TRUE
.	O	O
next	O	TRUE
(	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
decayedCost	O	TRUE
=	O	O
entry	O	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
0	O	O
)	O	O
;	O	O
AtomicLong	O	TRUE
rawCost	O	TRUE
=	O	O
entry	O	TRUE
.	O	O
getValue	O	TRUE
(	O	O
)	O	O
.	O	O
get	O	TRUE
(	O	O
1	O	O
)	O	O
;	O	O
totalRawCost	TRUE	TRUE
+=	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
currentValue	O	TRUE
=	O	O
decayedCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
nextValue	O	TRUE
=	O	O
(	O	O
long	O	O
)	O	O
(	O	O
currentValue	O	TRUE
*	O	O
decayFactor	O	TRUE
)	O	O
;	O	O
totalDecayedCost	TRUE	TRUE
+=	O	O
nextValue	O	TRUE
;	O	O
decayedCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
nextValue	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
entry	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
,	O	O
nextValue	O	TRUE
,	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
nextValue	O	TRUE
==	O	O
0	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
entry	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
it	O	TRUE
.	O	O
remove	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
totalDecayedCallCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
totalDecayedCost	TRUE	TRUE
)	O	O
;	O	O
totalRawCallCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
totalRawCost	TRUE	TRUE
)	O	O
;	O	O

totalRawCost	O	TRUE
+=	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
currentValue	O	TRUE
=	O	O
decayedCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
nextValue	O	TRUE
=	O	O
(	O	O
long	O	O
)	O	O
(	O	O
currentValue	O	TRUE
*	O	O
decayFactor	O	TRUE
)	O	O
;	O	O
totalDecayedCost	O	TRUE
+=	O	O
nextValue	O	TRUE
;	O	O
decayedCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
nextValue	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
entry	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
,	O	O
nextValue	O	TRUE
,	O	O
rawCost	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
nextValue	O	TRUE
==	O	O
0	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
entry	O	TRUE
.	O	O
getKey	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
it	O	TRUE
.	O	O
remove	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
}	O	O
totalDecayedCallCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
totalDecayedCost	O	TRUE
)	O	O
;	O	O
totalRawCallCost	O	TRUE
.	O	O
set	O	TRUE
(	O	O
totalRawCost	O	TRUE
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
,	O	O
totalDecayedCost	O	TRUE
,	O	O
totalRawCost	O	TRUE
)	O	O
;	O	O
recomputeScheduleCache	O	TRUE
(	O	O
)	O	O
;	O	O
updateAverageResponseTime	O	TRUE
(	O	O
true	O	O
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
Exception	O	O
ex	TRUE	TRUE
)	O	O
{	O	O

private	O	O
int	O	O
cachedOrComputedPriorityLevel	O	O
(	O	O
Object	O	TRUE
identity	TRUE	TRUE
)	O	O
{	O	O
Map	O	TRUE
<	O	O
Object	O	TRUE
,	O	O
Integer	O	TRUE
>	O	O
scheduleCache	O	TRUE
=	O	O
scheduleCacheRef	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
scheduleCache	O	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O
Integer	O	TRUE
priority	TRUE	TRUE
=	O	O
scheduleCache	O	TRUE
.	O	O
get	O	TRUE
(	O	O
identity	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
priority	TRUE	TRUE
!=	O	O
null	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
boolean	O	O
shouldBackOff	O	O
(	O	O
Schedulable	O	O
obj	O	TRUE
)	O	O
{	O	O
Boolean	O	TRUE
backOff	O	TRUE
=	O	O
false	O	O
;	O	O
if	O	O
(	O	O
backOffByResponseTimeEnabled	O	O
)	O	O
{	O	O
int	O	O
priorityLevel	O	TRUE
=	O	O
obj	O	TRUE
.	O	O
getPriorityLevel	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
double	O	O
[	O	O
]	O	O
responseTimes	TRUE	TRUE
=	O	O
getAverageResponseTime	O	TRUE
(	O	O
)	O	O
;	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
,	O	O
obj	O	TRUE
.	O	O
getUserGroupInformation	O	TRUE
(	O	O
)	O	O
.	O	O
getUserName	O	TRUE
(	O	O
)	O	O
,	O	O
obj	O	TRUE
.	O	O
getPriorityLevel	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
for	O	O
(	O	O
int	O	O
i	TRUE	TRUE
=	O	O
0	O	O
;	O	O
i	TRUE	TRUE
<	O	O
numLevels	O	O
;	O	O
i	TRUE	TRUE
++	O	O
)	O	O
{	O	O

@	O	O
Override	O	O
public	O	O
void	O	O
addResponseTime	O	O
(	O	O
String	O	TRUE
callName	TRUE	TRUE
,	O	O
Schedulable	O	O
schedulable	O	TRUE
,	O	O
ProcessingDetails	O	O
details	O	TRUE
)	O	O
{	O	O
String	O	TRUE
user	O	TRUE
=	O	O
identityProvider	O	TRUE
.	O	O
makeIdentity	O	TRUE
(	O	O
schedulable	O	TRUE
)	O	O
;	O	O
long	O	O
processingCost	O	TRUE
=	O	O
costProvider	O	TRUE
.	O	O
getCost	O	TRUE
(	O	O
details	O	TRUE
)	O	O
;	O	O
addCost	O	TRUE
(	O	O
user	O	TRUE
,	O	O
processingCost	O	TRUE
)	O	O
;	O	O
int	O	O
priorityLevel	TRUE	TRUE
=	O	O
schedulable	O	TRUE
.	O	O
getPriorityLevel	O	TRUE
(	O	O
)	O	O
;	O	O
long	O	O
queueTime	TRUE	TRUE
=	O	O
details	O	TRUE
.	O	O
get	O	TRUE
(	O	O
Timing	O	TRUE
.	O	O
QUEUE	O	TRUE
,	O	O
RpcMetrics	O	TRUE
.	O	O
TIMEUNIT	O	TRUE
)	O	O
;	O	O
long	O	O
processingTime	TRUE	TRUE
=	O	O
details	O	TRUE
.	O	O
get	O	TRUE
(	O	O
Timing	O	TRUE
.	O	O
PROCESSING	O	TRUE
,	O	O
RpcMetrics	O	TRUE
.	O	O
TIMEUNIT	O	TRUE
)	O	O
;	O	O
this	O	O
.	O	O
decayRpcSchedulerDetailedMetrics	O	TRUE
.	O	O
addQueueTime	O	TRUE
(	O	O
priorityLevel	TRUE	TRUE
,	O	O
queueTime	TRUE	TRUE
)	O	O
;	O	O
this	O	O
.	O	O
decayRpcSchedulerDetailedMetrics	O	TRUE
.	O	O
addProcessingTime	O	TRUE
(	O	O
priorityLevel	TRUE	TRUE
,	O	O
processingTime	TRUE	TRUE
)	O	O
;	O	O
responseTimeCountInCurrWindow	O	TRUE
.	O	O
getAndIncrement	O	TRUE
(	O	O
priorityLevel	TRUE	TRUE
)	O	O
;	O	O
responseTimeTotalInCurrWindow	O	TRUE
.	O	O
getAndAdd	O	TRUE
(	O	O
priorityLevel	TRUE	TRUE
,	O	O
queueTime	TRUE	TRUE
+	O	O
processingTime	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

long	O	O
totalResponseTime	O	TRUE
=	O	O
responseTimeTotalInCurrWindow	O	TRUE
.	O	O
get	O	TRUE
(	O	O
i	TRUE	TRUE
)	O	O
;	O	O
long	O	O
responseTimeCount	TRUE	TRUE
=	O	O
responseTimeCountInCurrWindow	O	TRUE
.	O	O
get	O	TRUE
(	O	O
i	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
responseTimeCount	TRUE	TRUE
>	O	O
0	O	O
)	O	O
{	O	O
averageResponseTime	TRUE	TRUE
=	O	O
(	O	O
double	O	O
)	O	O
totalResponseTime	O	TRUE
/	O	O
responseTimeCount	TRUE	TRUE
;	O	O
}	O	O
final	O	O
double	O	O
lastAvg	O	TRUE
=	O	O
responseTimeAvgInLastWindow	O	TRUE
.	O	O
get	O	TRUE
(	O	O
i	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
lastAvg	O	TRUE
>	O	O
PRECISION	O	O
||	O	O
averageResponseTime	TRUE	TRUE
>	O	O
PRECISION	O	O
)	O	O
{	O	O
if	O	O
(	O	O
enableDecay	O	O
)	O	O
{	O	O
final	O	O
double	O	O
decayed	O	TRUE
=	O	O
decayFactor	O	TRUE
*	O	O
lastAvg	O	TRUE
+	O	O
averageResponseTime	TRUE	TRUE
;	O	O
responseTimeAvgInLastWindow	O	TRUE
.	O	O
set	O	TRUE
(	O	O
i	TRUE	TRUE
,	O	O
decayed	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
responseTimeAvgInLastWindow	O	TRUE
.	O	O
set	O	TRUE
(	O	O
i	TRUE	TRUE
,	O	O
averageResponseTime	TRUE	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
else	O	O
{	O	O
responseTimeAvgInLastWindow	O	TRUE
.	O	O
set	O	TRUE
(	O	O
i	TRUE	TRUE
,	O	O
0	O	O
)	O	O
;	O	O
}	O	O
responseTimeCountInLastWindow	O	TRUE
.	O	O
set	O	TRUE
(	O	O
i	TRUE	TRUE
,	O	O
responseTimeCount	TRUE	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

public	O	O
static	O	O
void	O	O
stopProxy	O	O
(	O	O
Object	O	O
proxy	O	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
proxy	O	TRUE
==	O	O
null	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
HadoopIllegalArgumentException	O	TRUE
(	O	O
)	O	O
;	O	O
}	O	O
try	O	O
{	O	O
if	O	O
(	O	O
proxy	O	TRUE
instanceof	O	O
Closeable	O	TRUE
)	O	O
{	O	O
(	O	O
(	O	O
Closeable	O	TRUE
)	O	O
proxy	O	TRUE
)	O	O
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
return	O	O
;	O	O
}	O	O
else	O	O
{	O	O
InvocationHandler	O	TRUE
handler	O	TRUE
=	O	O
Proxy	O	TRUE
.	O	O
getInvocationHandler	O	TRUE
(	O	O
proxy	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
handler	O	TRUE
instanceof	O	O
Closeable	O	TRUE
)	O	O
{	O	O
(	O	O
(	O	O
Closeable	O	TRUE
)	O	O
handler	O	TRUE
)	O	O
.	O	O
close	O	TRUE
(	O	O
)	O	O
;	O	O
return	O	O
;	O	O
}	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	O
e	TRUE	TRUE
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
error	O	TRUE
(	O	O
,	O	O
e	TRUE	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IllegalArgumentException	O	O
e	TRUE	TRUE
)	O	O
{	O	O

RpcSaslProto	O	TRUE
saslResponse	O	TRUE
=	O	O
null	O	O
;	O	O
try	O	O
{	O	O
try	O	O
{	O	O
saslResponse	O	TRUE
=	O	O
processSaslMessage	O	TRUE
(	O	O
saslMessage	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	TRUE
e	O	TRUE
)	O	O
{	O	O
rpcMetrics	O	TRUE
.	O	O
incrAuthenticationFailures	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
StringUtils	O	TRUE
.	O	O
stringifyException	O	TRUE
(	O	O
e	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
IOException	O	TRUE
tce	O	TRUE
=	O	O
(	O	O
IOException	O	TRUE
)	O	O
getTrueCause	O	TRUE
(	O	O
e	O	TRUE
)	O	O
;	O	O
AUDITLOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
AUTH_FAILED_FOR	O	TRUE
+	O	O
this	O	O
.	O	O
toString	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
attemptingUser	O	TRUE
+	O	O
+	O	O
e	O	TRUE
.	O	O
getLocalizedMessage	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
tce	O	TRUE
.	O	O
getLocalizedMessage	O	TRUE
(	O	O
)	O	O
+	O	O
)	O	O
;	O	O
throw	O	O
tce	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
saslServer	O	TRUE
!=	O	O
null	O	O
&&	O	O
saslServer	O	TRUE
.	O	O
isComplete	O	O
(	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
saslServer	O	TRUE
.	O	O
getNegotiatedProperty	O	TRUE
(	O	O
Sasl	O	TRUE
.	O	O
QOP	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
user	TRUE	TRUE
=	O	O
getAuthorizedUgi	O	TRUE
(	O	O
saslServer	O	TRUE
.	O	O
getAuthorizationID	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O

try	O	O
{	O	O
saslResponse	O	TRUE
=	O	O
processSaslMessage	O	TRUE
(	O	O
saslMessage	O	TRUE
)	O	O
;	O	O
}	O	O
catch	O	O
(	O	O
IOException	O	TRUE
e	O	TRUE
)	O	O
{	O	O
rpcMetrics	O	TRUE
.	O	O
incrAuthenticationFailures	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
StringUtils	O	TRUE
.	O	O
stringifyException	O	TRUE
(	O	O
e	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
IOException	O	TRUE
tce	O	TRUE
=	O	O
(	O	O
IOException	O	TRUE
)	O	O
getTrueCause	O	TRUE
(	O	O
e	O	TRUE
)	O	O
;	O	O
AUDITLOG	O	TRUE
.	O	O
warn	O	TRUE
(	O	O
AUTH_FAILED_FOR	O	TRUE
+	O	O
this	O	O
.	O	O
toString	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
attemptingUser	O	TRUE
+	O	O
+	O	O
e	O	TRUE
.	O	O
getLocalizedMessage	O	TRUE
(	O	O
)	O	O
+	O	O
+	O	O
tce	O	TRUE
.	O	O
getLocalizedMessage	O	TRUE
(	O	O
)	O	O
+	O	O
)	O	O
;	O	O
throw	O	O
tce	O	TRUE
;	O	O
}	O	O
if	O	O
(	O	O
saslServer	O	TRUE
!=	O	O
null	O	O
&&	O	O
saslServer	O	TRUE
.	O	O
isComplete	O	O
(	O	O
)	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
saslServer	O	TRUE
.	O	O
getNegotiatedProperty	O	TRUE
(	O	O
Sasl	O	TRUE
.	O	O
QOP	O	TRUE
)	O	O
)	O	O
;	O	O
}	O	O
user	TRUE	TRUE
=	O	O
getAuthorizedUgi	O	TRUE
(	O	O
saslServer	O	TRUE
.	O	O
getAuthorizationID	O	TRUE
(	O	O
)	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
user	TRUE	TRUE
)	O	O
;	O	O

private	O	O
RpcSaslProto	O	O
buildSaslResponse	O	O
(	O	O
SaslState	O	O
state	TRUE	TRUE
,	O	O
byte	O	O
[	O	O
]	O	O
replyToken	O	O
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
void	O	O
unwrapPacketAndProcessRpcs	O	O
(	O	O
byte	O	O
[	O	O
]	O	O
inBuf	TRUE	TRUE
)	O	O
throws	O	O
IOException	O	O
,	O	O
InterruptedException	O	O
{	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
void	O	O
processOneRpc	O	O
(	O	O
ByteBuffer	O	O
bb	O	TRUE
)	O	O
throws	O	O
IOException	O	O
,	O	O
InterruptedException	O	O
{	O	O
int	O	O
callId	TRUE	TRUE
=	O	O
-	O	O
1	O	O
;	O	O
int	O	O
retry	O	TRUE
=	O	O
RpcConstants	O	TRUE
.	O	O
INVALID_RETRY_COUNT	O	TRUE
;	O	O
try	O	O
{	O	O
final	O	O
RpcWritable	O	TRUE
.	O	O
Buffer	O	TRUE
buffer	O	TRUE
=	O	O
RpcWritable	O	TRUE
.	O	O
Buffer	O	TRUE
.	O	O
wrap	O	TRUE
(	O	O
bb	O	TRUE
)	O	O
;	O	O
final	O	O
RpcRequestHeaderProto	O	TRUE
header	O	TRUE
=	O	O
getMessage	O	TRUE
(	O	O
RpcRequestHeaderProto	O	TRUE
.	O	O
getDefaultInstance	O	TRUE
(	O	O
)	O	O
,	O	O
buffer	O	TRUE
)	O	O
;	O	O
callId	TRUE	TRUE
=	O	O
header	O	TRUE
.	O	O
getCallId	O	TRUE
(	O	O
)	O	O
;	O	O
retry	O	TRUE
=	O	O
header	O	TRUE
.	O	O
getRetryCount	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	O
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

final	O	O
RpcWritable	O	TRUE
.	O	O
Buffer	O	TRUE
buffer	O	TRUE
=	O	O
RpcWritable	O	TRUE
.	O	O
Buffer	O	TRUE
.	O	O
wrap	O	TRUE
(	O	O
bb	O	TRUE
)	O	O
;	O	O
final	O	O
RpcRequestHeaderProto	O	TRUE
header	O	TRUE
=	O	O
getMessage	O	TRUE
(	O	O
RpcRequestHeaderProto	O	TRUE
.	O	O
getDefaultInstance	O	TRUE
(	O	O
)	O	O
,	O	O
buffer	O	TRUE
)	O	O
;	O	O
callId	O	TRUE
=	O	O
header	O	TRUE
.	O	O
getCallId	O	TRUE
(	O	O
)	O	O
;	O	O
retry	O	TRUE
=	O	O
header	O	TRUE
.	O	O
getRetryCount	O	TRUE
(	O	O
)	O	O
;	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O
LOG	O	TRUE
.	O	O
debug	O	TRUE
(	O	O
+	O	O
callId	O	TRUE
)	O	O
;	O	O
}	O	O
checkRpcHeaders	O	TRUE
(	O	O
header	O	TRUE
)	O	O
;	O	O
if	O	O
(	O	O
callId	O	TRUE
<	O	O
0	O	O
)	O	O
{	O	O
processRpcOutOfBandRequest	O	TRUE
(	O	O
header	O	TRUE
,	O	O
buffer	O	TRUE
)	O	O
;	O	O
}	O	O
else	O	O
if	O	O
(	O	O
!	O	O
connectionContextRead	O	O
)	O	O
{	O	O
throw	O	O
new	O	O
FatalRpcServerException	O	TRUE
(	O	O
RpcErrorCodeProto	O	TRUE
.	O	O
FATAL_INVALID_RPC_HEADER	O	TRUE
,	O	O
)	O	O
;	O	O
}	O	O
else	O	O
{	O	O
processRpcRequest	O	TRUE
(	O	O
header	O	TRUE
,	O	O
buffer	O	TRUE
)	O	O
;	O	O
}	O	O
}	O	O
catch	O	O
(	O	O
RpcServerException	O	O
rse	TRUE	TRUE
)	O	O
{	O	O
if	O	O
(	O	O
LOG	O	TRUE
.	O	O
isDebugEnabled	O	O
(	O	O
)	O	O
)	O	O
{	O	O

private	O	O
void	O	O
moveToNextQueue	O	O
(	O	O
)	O	O
{	O	O
int	O	O
thisIdx	TRUE	TRUE
=	O	O
this	O	O
.	O	O
currentQueueIndex	O	TRUE
.	O	O
get	O	TRUE
(	O	O
)	O	O
;	O	O
int	O	O
nextIdx	TRUE	TRUE
=	O	O
(	O	O
thisIdx	TRUE	TRUE
+	O	O
1	O	O
)	O	O
%	O	O
this	O	O
.	O	O
numQueues	O	TRUE
;	O	O
this	O	O
.	O	O
currentQueueIndex	O	TRUE
.	O	O
set	O	TRUE
(	O	O
nextIdx	TRUE	TRUE
)	O	O
;	O	O
this	O	O
.	O	O
requestsLeft	TRUE	TRUE
.	O	O
set	O	TRUE
(	O	O
this	O	O
.	O	O
queueWeights	O	TRUE
[	O	O
nextIdx	TRUE	TRUE
]	O	O
)	O	O
;	O	O

public	O	O
void	O	O
init	O	O
(	O	O
int	O	O
numLevels	TRUE	TRUE
)	O	O
{	O	O

